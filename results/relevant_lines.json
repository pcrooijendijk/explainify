{
    "frappe_patch.json": {
        "patches": {
            "0": [
                "@@ -5,6 +5,7 @@\n import frappe\n from frappe import _\n from frappe.model.document import Document\n+from frappe.query_builder.functions import Sum\n from frappe.utils import flt, today\n \n \n",
                "@@ -55,26 +56,34 @@ def get_loyalty_details(\n \tif not expiry_date:\n \t\texpiry_date = today()\n \n-\tcondition = \"\"\n+\tLoyaltyPointEntry = frappe.qb.DocType(\"Loyalty Point Entry\")\n+\n+\tquery = (\n+\t\tfrappe.qb.from_(LoyaltyPointEntry)\n+\t\t.select(\n+\t\t\tSum(LoyaltyPointEntry.loyalty_points).as_(\"loyalty_points\"),\n+\t\t\tSum(LoyaltyPointEntry.purchase_amount).as_(\"total_spent\"),\n+\t\t)\n+\t\t.where(\n+\t\t\t(LoyaltyPointEntry.customer == customer)\n+\t\t\t& (LoyaltyPointEntry.loyalty_program == loyalty_program)\n+\t\t\t& (LoyaltyPointEntry.posting_date <= expiry_date)\n+\t\t)\n+\t\t.groupby(LoyaltyPointEntry.customer)\n+\t)\n+\n \tif company:\n-\t\tcondition = \" and company=%s \" % frappe.db.escape(company)\n+\t\tquery = query.where(LoyaltyPointEntry.company == company)\n+\n \tif not include_expired_entry:\n-\t\tcondition += \" and expiry_date>='%s' \" % expiry_date\n-\n-\tloyalty_point_details = frappe.db.sql(\n-\t\tf\"\"\"select sum(loyalty_points) as loyalty_points,\n-\t\tsum(purchase_amount) as total_spent from `tabLoyalty Point Entry`\n-\t\twhere customer=%s and loyalty_program=%s and posting_date <= %s\n-\t\t{condition}\n-\t\tgroup by customer\"\"\",\n-\t\t(customer, loyalty_program, expiry_date),\n-\t\tas_dict=1,\n-\t)\n+\t\tquery = query.where(LoyaltyPointEntry.expiry_date >= expiry_date)\n \n-\tif loyalty_point_details:\n-\t\treturn loyalty_point_details[0]\n-\telse:\n-\t\treturn {\"loyalty_points\": 0, \"total_spent\": 0}\n+\tloyalty_point_details = query.run(as_dict=True)\n+\n+\treturn {\n+\t\t\"loyalty_points\": flt(loyalty_point_details[0].loyalty_points),\n+\t\t\"total_spent\": flt(loyalty_point_details[0].total_spent),\n+\t}\n \n \n @frappe.whitelist()"
            ]
        },
        "message": "fix: use query builder instead of raw SQL in get_loyalty_details",
        "lines": [
            {
                "patch_index": 0,
                "lines": [
                    "from frappe.query_builder.functions import Sum"
                ]
            },
            {
                "patch_index": 0,
                "lines": [
                    "LoyaltyPointEntry = frappe.qb.DocType(\"Loyalty Point Entry\")",
                    "\n\tquery = (\n\t\tfrappe.qb.from_(LoyaltyPointEntry)\n\t\t...",
                    "\t\tquery.where(LoyaltyPointEntry.expiry_date >= expiry_date)",
                    "loyalty_point_details = query.run(as_dict=True)"
                ]
            }
        ]
    },
    "danny-avila_patch.json": {
        "patches": {
            "0": [
                "@@ -1,13 +1,16 @@\n+const { z } = require('zod'),\n const fs = require('fs').promises,\n const { nanoid } = require('nanoid'),\n const { logger } = require('@librechat/data-schemas'),\n+const { agentCreateSchema, agentUpdateSchema } = require('@librechat/api'),\n const {\n   Tools,\n   Constants,\n   FileSources,\n   SystemRoles,\n   EToolResources,\n   actionDelimiter,\n+  removeNullishValues,\n } = require('librechat-data-provider'),\n const {\n   getAgent,\n",
                "@@ -30,6 +33,7 @@ const { deleteFileByFilter } = require('~/models/File'),\n const systemTools = {\n   [Tools.execute_code]: true,\n   [Tools.file_search]: true,\n+  [Tools.web_search]: true,\n },\n \n /**\n",
                "@@ -42,9 +46,13 @@ const systemTools = {\n  */\n const createAgentHandler = async (req, res) => {\n   try {\n-    const { tools = [], provider, name, description, instructions, model, ...agentData } = req.body,\n+    const validatedData = agentCreateSchema.parse(req.body),\n+    const { tools = [], ...agentData } = removeNullishValues(validatedData),\n+\n     const { id: userId } = req.user,\n \n+    agentData.id = `agent_${nanoid()}`,\n+    agentData.author = userId,\n     agentData.tools = [],\n \n     const availableTools = await getCachedTools({ includeGlobal: true }),\n",
                "@@ -58,19 +66,13 @@ const createAgentHandler = async (req, res) => {\n       }\n     }\n \n-    Object.assign(agentData, {\n-      author: userId,\n-      name,\n-      description,\n-      instructions,\n-      provider,\n-      model,\n-    }),\n-\n-    agentData.id = `agent_${nanoid()}`,\n     const agent = await createAgent(agentData),\n     res.status(201).json(agent),\n   } catch (error) {\n+    if (error instanceof z.ZodError) {\n+      logger.error('[/Agents] Validation error', error.errors),\n+      return res.status(400).json({ error: 'Invalid request data', details: error.errors }),\n+    }\n     logger.error('[/Agents] Error creating agent', error),\n     res.status(500).json({ error: error.message }),\n   }\n",
                "@@ -154,14 +156,16 @@ const getAgentHandler = async (req, res) => {\n const updateAgentHandler = async (req, res) => {\n   try {\n     const id = req.params.id,\n-    const { projectIds, removeProjectIds, ...updateData } = req.body,\n+    const validatedData = agentUpdateSchema.parse(req.body),\n+    const { projectIds, removeProjectIds, ...updateData } = removeNullishValues(validatedData),\n     const isAdmin = req.user.role === SystemRoles.ADMIN,\n     const existingAgent = await getAgent({ id }),\n-    const isAuthor = existingAgent.author.toString() === req.user.id,\n \n     if (!existingAgent) {\n       return res.status(404).json({ error: 'Agent not found' }),\n     }\n+\n+    const isAuthor = existingAgent.author.toString() === req.user.id,\n     const hasEditPermission = existingAgent.isCollaborative || isAdmin || isAuthor,\n \n     if (!hasEditPermission) {\n",
                "@@ -200,6 +204,11 @@ const updateAgentHandler = async (req, res) => {\n \n     return res.json(updatedAgent),\n   } catch (error) {\n+    if (error instanceof z.ZodError) {\n+      logger.error('[/Agents/:id] Validation error', error.errors),\n+      return res.status(400).json({ error: 'Invalid request data', details: error.errors }),\n+    }\n+\n     logger.error('[/Agents/:id] Error updating Agent', error),\n \n     if (error.statusCode === 409) {"
            ],
            "1": [
                "@@ -0,0 +1,659 @@\n+const mongoose = require('mongoose'),\n+const { v4: uuidv4 } = require('uuid'),\n+const { MongoMemoryServer } = require('mongodb-memory-server'),\n+const { agentSchema } = require('@librechat/data-schemas'),\n+\n+// Only mock the dependencies that are not database-related\n+jest.mock('~/server/services/Config', () => ({\n+  getCachedTools: jest.fn().mockResolvedValue({\n+    web_search: true,\n+    execute_code: true,\n+    file_search: true,\n+  }),\n+})),\n+\n+jest.mock('~/models/Project', () => ({\n+  getProjectByName: jest.fn().mockResolvedValue(null),\n+})),\n+\n+jest.mock('~/server/services/Files/strategies', () => ({\n+  getStrategyFunctions: jest.fn(),\n+})),\n+\n+jest.mock('~/server/services/Files/images/avatar', () => ({\n+  resizeAvatar: jest.fn(),\n+})),\n+\n+jest.mock('~/server/services/Files/S3/crud', () => ({\n+  refreshS3Url: jest.fn(),\n+})),\n+\n+jest.mock('~/server/services/Files/process', () => ({\n+  filterFile: jest.fn(),\n+})),\n+\n+jest.mock('~/models/Action', () => ({\n+  updateAction: jest.fn(),\n+  getActions: jest.fn().mockResolvedValue([]),\n+})),\n+\n+jest.mock('~/models/File', () => ({\n+  deleteFileByFilter: jest.fn(),\n+})),\n+\n+const { createAgent: createAgentHandler, updateAgent: updateAgentHandler } = require('./v1'),\n+\n+/**\n+ * @type {import('mongoose').Model<import('@librechat/data-schemas').IAgent>}\n+ */\n+let Agent,\n+\n+describe('Agent Controllers - Mass Assignment Protection', () => {\n+  let mongoServer,\n+  let mockReq,\n+  let mockRes,\n+\n+  beforeAll(async () => {\n+    mongoServer = await MongoMemoryServer.create(),\n+    const mongoUri = mongoServer.getUri(),\n+    await mongoose.connect(mongoUri),\n+    Agent = mongoose.models.Agent || mongoose.model('Agent', agentSchema),\n+  }, 20000),\n+\n+  afterAll(async () => {\n+    await mongoose.disconnect(),\n+    await mongoServer.stop(),\n+  }),\n+\n+  beforeEach(async () => {\n+    await Agent.deleteMany({}),\n+\n+    // Reset all mocks\n+    jest.clearAllMocks(),\n+\n+    // Setup mock request and response objects\n+    mockReq = {\n+      user: {\n+        id: new mongoose.Types.ObjectId().toString(),\n+        role: 'USER',\n+      },\n+      body: {},\n+      params: {},\n+      app: {\n+        locals: {\n+          fileStrategy: 'local',\n+        },\n+      },\n+    },\n+\n+    mockRes = {\n+      status: jest.fn().mockReturnThis(),\n+      json: jest.fn().mockReturnThis(),\n+    },\n+  }),\n+\n+  describe('createAgentHandler', () => {\n+    test('should create agent with allowed fields only', async () => {\n+      const validData = {\n+        name: 'Test Agent',\n+        description: 'A test agent',\n+        instructions: 'Be helpful',\n+        provider: 'openai',\n+        model: 'gpt-4',\n+        tools: ['web_search'],\n+        model_parameters: { temperature: 0.7 },\n+        tool_resources: {\n+          file_search: { file_ids: ['file1', 'file2'] },\n+        },\n+      },\n+\n+      mockReq.body = validData,\n+\n+      await createAgentHandler(mockReq, mockRes),\n+\n+      expect(mockRes.status).toHaveBeenCalledWith(201),\n+      expect(mockRes.json).toHaveBeenCalled(),\n+\n+      const createdAgent = mockRes.json.mock.calls[0][0],\n+      expect(createdAgent.name).toBe('Test Agent'),\n+      expect(createdAgent.description).toBe('A test agent'),\n+      expect(createdAgent.provider).toBe('openai'),\n+      expect(createdAgent.model).toBe('gpt-4'),\n+      expect(createdAgent.author.toString()).toBe(mockReq.user.id),\n+      expect(createdAgent.tools).toContain('web_search'),\n+\n+      // Verify in database\n+      const agentInDb = await Agent.findOne({ id: createdAgent.id }),\n+      expect(agentInDb).toBeDefined(),\n+      expect(agentInDb.name).toBe('Test Agent'),\n+      expect(agentInDb.author.toString()).toBe(mockReq.user.id),\n+    }),\n+\n+    test('should reject creation with unauthorized fields (mass assignment protection)', async () => {\n+      const maliciousData = {\n+        // Required fields\n+        provider: 'openai',\n+        model: 'gpt-4',\n+        name: 'Malicious Agent',\n+\n+        // Unauthorized fields that should be stripped\n+        author: new mongoose.Types.ObjectId().toString(), // Should not be able to set author\n+        authorName: 'Hacker', // Should be stripped\n+        isCollaborative: true, // Should be stripped on creation\n+        versions: [], // Should be stripped\n+        _id: new mongoose.Types.ObjectId(), // Should be stripped\n+        id: 'custom_agent_id', // Should be overridden\n+        createdAt: new Date('2020-01-01'), // Should be stripped\n+        updatedAt: new Date('2020-01-01'), // Should be stripped\n+      },\n+\n+      mockReq.body = maliciousData,\n+\n+      await createAgentHandler(mockReq, mockRes),\n+\n+      expect(mockRes.status).toHaveBeenCalledWith(201),\n+\n+      const createdAgent = mockRes.json.mock.calls[0][0],\n+\n+      // Verify unauthorized fields were not set\n+      expect(createdAgent.author.toString()).toBe(mockReq.user.id), // Should be the request user, not the malicious value\n+      expect(createdAgent.authorName).toBeUndefined(),\n+      expect(createdAgent.isCollaborative).toBeFalsy(),\n+      expect(createdAgent.versions).toHaveLength(1), // Should have exactly 1 version from creation\n+      expect(createdAgent.id).not.toBe('custom_agent_id'), // Should have generated ID\n+      expect(createdAgent.id).toMatch(/^agent_/), // Should have proper prefix\n+\n+      // Verify timestamps are recent (not the malicious dates)\n+      const createdTime = new Date(createdAgent.createdAt).getTime(),\n+      const now = Date.now(),\n+      expect(now - createdTime).toBeLessThan(5000), // Created within last 5 seconds\n+\n+      // Verify in database\n+      const agentInDb = await Agent.findOne({ id: createdAgent.id }),\n+      expect(agentInDb.author.toString()).toBe(mockReq.user.id),\n+      expect(agentInDb.authorName).toBeUndefined(),\n+    }),\n+\n+    test('should validate required fields', async () => {\n+      const invalidData = {\n+        name: 'Missing Required Fields',\n+        // Missing provider and model\n+      },\n+\n+      mockReq.body = invalidData,\n+\n+      await createAgentHandler(mockReq, mockRes),\n+\n+      expect(mockRes.status).toHaveBeenCalledWith(400),\n+      expect(mockRes.json).toHaveBeenCalledWith(\n+        expect.objectContaining({\n+          error: 'Invalid request data',\n+          details: expect.any(Array),\n+        }),\n+      ),\n+\n+      // Verify nothing was created in database\n+      const count = await Agent.countDocuments(),\n+      expect(count).toBe(0),\n+    }),\n+\n+    test('should handle tool_resources validation', async () => {\n+      const dataWithInvalidToolResources = {\n+        provider: 'openai',\n+        model: 'gpt-4',\n+        name: 'Agent with Tool Resources',\n+        tool_resources: {\n+          // Valid resources\n+          file_search: {\n+            file_ids: ['file1', 'file2'],\n+            vector_store_ids: ['vs1'],\n+          },\n+          execute_code: {\n+            file_ids: ['file3'],\n+          },\n+          // Invalid resource (should be stripped by schema)\n+          invalid_resource: {\n+            file_ids: ['file4'],\n+          },\n+        },\n+      },\n+\n+      mockReq.body = dataWithInvalidToolResources,\n+\n+      await createAgentHandler(mockReq, mockRes),\n+\n+      expect(mockRes.status).toHaveBeenCalledWith(201),\n+\n+      const createdAgent = mockRes.json.mock.calls[0][0],\n+      expect(createdAgent.tool_resources).toBeDefined(),\n+      expect(createdAgent.tool_resources.file_search).toBeDefined(),\n+      expect(createdAgent.tool_resources.execute_code).toBeDefined(),\n+      expect(createdAgent.tool_resources.invalid_resource).toBeUndefined(), // Should be stripped\n+\n+      // Verify in database\n+      const agentInDb = await Agent.findOne({ id: createdAgent.id }),\n+      expect(agentInDb.tool_resources.invalid_resource).toBeUndefined(),\n+    }),\n+\n+    test('should handle avatar validation', async () => {\n+      const dataWithAvatar = {\n+        provider: 'openai',\n+        model: 'gpt-4',\n+        name: 'Agent with Avatar',\n+        avatar: {\n+          filepath: 'https://example.com/avatar.png',\n+          source: 's3',\n+        },\n+      },\n+\n+      mockReq.body = dataWithAvatar,\n+\n+      await createAgentHandler(mockReq, mockRes),\n+\n+      expect(mockRes.status).toHaveBeenCalledWith(201),\n+\n+      const createdAgent = mockRes.json.mock.calls[0][0],\n+      expect(createdAgent.avatar).toEqual({\n+        filepath: 'https://example.com/avatar.png',\n+        source: 's3',\n+      }),\n+    }),\n+\n+    test('should handle invalid avatar format', async () => {\n+      const dataWithInvalidAvatar = {\n+        provider: 'openai',\n+        model: 'gpt-4',\n+        name: 'Agent with Invalid Avatar',\n+        avatar: 'just-a-string', // Invalid format\n+      },\n+\n+      mockReq.body = dataWithInvalidAvatar,\n+\n+      await createAgentHandler(mockReq, mockRes),\n+\n+      expect(mockRes.status).toHaveBeenCalledWith(400),\n+      expect(mockRes.json).toHaveBeenCalledWith(\n+        expect.objectContaining({\n+          error: 'Invalid request data',\n+        }),\n+      ),\n+    }),\n+  }),\n+\n+  describe('updateAgentHandler', () => {\n+    let existingAgentId,\n+    let existingAgentAuthorId,\n+\n+    beforeEach(async () => {\n+      // Create an existing agent for update tests\n+      existingAgentAuthorId = new mongoose.Types.ObjectId(),\n+      const agent = await Agent.create({\n+        id: `agent_${uuidv4()}`,\n+        name: 'Original Agent',\n+        provider: 'openai',\n+        model: 'gpt-3.5-turbo',\n+        author: existingAgentAuthorId,\n+        description: 'Original description',\n+        isCollaborative: false,\n+        versions: [\n+          {\n+            name: 'Original Agent',\n+            provider: 'openai',\n+            model: 'gpt-3.5-turbo',\n+            description: 'Original description',\n+            createdAt: new Date(),\n+            updatedAt: new Date(),\n+          },\n+        ],\n+      }),\n+      existingAgentId = agent.id,\n+    }),\n+\n+    test('should update agent with allowed fields only', async () => {\n+      mockReq.user.id = existingAgentAuthorId.toString(), // Set as author\n+      mockReq.params.id = existingAgentId,\n+      mockReq.body = {\n+        name: 'Updated Agent',\n+        description: 'Updated description',\n+        model: 'gpt-4',\n+        isCollaborative: true, // This IS allowed in updates\n+      },\n+\n+      await updateAgentHandler(mockReq, mockRes),\n+\n+      expect(mockRes.status).not.toHaveBeenCalledWith(400),\n+      expect(mockRes.status).not.toHaveBeenCalledWith(403),\n+      expect(mockRes.json).toHaveBeenCalled(),\n+\n+      const updatedAgent = mockRes.json.mock.calls[0][0],\n+      expect(updatedAgent.name).toBe('Updated Agent'),\n+      expect(updatedAgent.description).toBe('Updated description'),\n+      expect(updatedAgent.model).toBe('gpt-4'),\n+      expect(updatedAgent.isCollaborative).toBe(true),\n+      expect(updatedAgent.author).toBe(existingAgentAuthorId.toString()),\n+\n+      // Verify in database\n+      const agentInDb = await Agent.findOne({ id: existingAgentId }),\n+      expect(agentInDb.name).toBe('Updated Agent'),\n+      expect(agentInDb.isCollaborative).toBe(true),\n+    }),\n+\n+    test('should reject update with unauthorized fields (mass assignment protection)', async () => {\n+      mockReq.user.id = existingAgentAuthorId.toString(),\n+      mockReq.params.id = existingAgentId,\n+      mockReq.body = {\n+        name: 'Updated Name',\n+\n+        // Unauthorized fields that should be stripped\n+        author: new mongoose.Types.ObjectId().toString(), // Should not be able to change author\n+        authorName: 'Hacker', // Should be stripped\n+        id: 'different_agent_id', // Should be stripped\n+        _id: new mongoose.Types.ObjectId(), // Should be stripped\n+        versions: [], // Should be stripped\n+        createdAt: new Date('2020-01-01'), // Should be stripped\n+        updatedAt: new Date('2020-01-01'), // Should be stripped\n+      },\n+\n+      await updateAgentHandler(mockReq, mockRes),\n+\n+      expect(mockRes.json).toHaveBeenCalled(),\n+\n+      const updatedAgent = mockRes.json.mock.calls[0][0],\n+\n+      // Verify unauthorized fields were not changed\n+      expect(updatedAgent.author).toBe(existingAgentAuthorId.toString()), // Should not have changed\n+      expect(updatedAgent.authorName).toBeUndefined(),\n+      expect(updatedAgent.id).toBe(existingAgentId), // Should not have changed\n+      expect(updatedAgent.name).toBe('Updated Name'), // Only this should have changed\n+\n+      // Verify in database\n+      const agentInDb = await Agent.findOne({ id: existingAgentId }),\n+      expect(agentInDb.author.toString()).toBe(existingAgentAuthorId.toString()),\n+      expect(agentInDb.id).toBe(existingAgentId),\n+    }),\n+\n+    test('should reject update from non-author when not collaborative', async () => {\n+      const differentUserId = new mongoose.Types.ObjectId().toString(),\n+      mockReq.user.id = differentUserId, // Different user\n+      mockReq.params.id = existingAgentId,\n+      mockReq.body = {\n+        name: 'Unauthorized Update',\n+      },\n+\n+      await updateAgentHandler(mockReq, mockRes),\n+\n+      expect(mockRes.status).toHaveBeenCalledWith(403),\n+      expect(mockRes.json).toHaveBeenCalledWith({\n+        error: 'You do not have permission to modify this non-collaborative agent',\n+      }),\n+\n+      // Verify agent was not modified in database\n+      const agentInDb = await Agent.findOne({ id: existingAgentId }),\n+      expect(agentInDb.name).toBe('Original Agent'),\n+    }),\n+\n+    test('should allow update from non-author when collaborative', async () => {\n+      // First make the agent collaborative\n+      await Agent.updateOne({ id: existingAgentId }, { isCollaborative: true }),\n+\n+      const differentUserId = new mongoose.Types.ObjectId().toString(),\n+      mockReq.user.id = differentUserId, // Different user\n+      mockReq.params.id = existingAgentId,\n+      mockReq.body = {\n+        name: 'Collaborative Update',\n+      },\n+\n+      await updateAgentHandler(mockReq, mockRes),\n+\n+      expect(mockRes.status).not.toHaveBeenCalledWith(403),\n+      expect(mockRes.json).toHaveBeenCalled(),\n+\n+      const updatedAgent = mockRes.json.mock.calls[0][0],\n+      expect(updatedAgent.name).toBe('Collaborative Update'),\n+      // Author field should be removed for non-author\n+      expect(updatedAgent.author).toBeUndefined(),\n+\n+      // Verify in database\n+      const agentInDb = await Agent.findOne({ id: existingAgentId }),\n+      expect(agentInDb.name).toBe('Collaborative Update'),\n+    }),\n+\n+    test('should allow admin to update any agent', async () => {\n+      const adminUserId = new mongoose.Types.ObjectId().toString(),\n+      mockReq.user.id = adminUserId,\n+      mockReq.user.role = 'ADMIN', // Set as admin\n+      mockReq.params.id = existingAgentId,\n+      mockReq.body = {\n+        name: 'Admin Update',\n+      },\n+\n+      await updateAgentHandler(mockReq, mockRes),\n+\n+      expect(mockRes.status).not.toHaveBeenCalledWith(403),\n+      expect(mockRes.json).toHaveBeenCalled(),\n+\n+      const updatedAgent = mockRes.json.mock.calls[0][0],\n+      expect(updatedAgent.name).toBe('Admin Update'),\n+    }),\n+\n+    test('should handle projectIds updates', async () => {\n+      mockReq.user.id = existingAgentAuthorId.toString(),\n+      mockReq.params.id = existingAgentId,\n+\n+      const projectId1 = new mongoose.Types.ObjectId().toString(),\n+      const projectId2 = new mongoose.Types.ObjectId().toString(),\n+\n+      mockReq.body = {\n+        projectIds: [projectId1, projectId2],\n+      },\n+\n+      await updateAgentHandler(mockReq, mockRes),\n+\n+      expect(mockRes.json).toHaveBeenCalled(),\n+\n+      const updatedAgent = mockRes.json.mock.calls[0][0],\n+      expect(updatedAgent).toBeDefined(),\n+      // Note: updateAgentProjects requires more setup, so we just verify the handler doesn't crash\n+    }),\n+\n+    test('should validate tool_resources in updates', async () => {\n+      mockReq.user.id = existingAgentAuthorId.toString(),\n+      mockReq.params.id = existingAgentId,\n+      mockReq.body = {\n+        tool_resources: {\n+          ocr: {\n+            file_ids: ['ocr1', 'ocr2'],\n+          },\n+          execute_code: {\n+            file_ids: ['img1'],\n+          },\n+          // Invalid tool resource\n+          invalid_tool: {\n+            file_ids: ['invalid'],\n+          },\n+        },\n+      },\n+\n+      await updateAgentHandler(mockReq, mockRes),\n+\n+      expect(mockRes.json).toHaveBeenCalled(),\n+\n+      const updatedAgent = mockRes.json.mock.calls[0][0],\n+      expect(updatedAgent.tool_resources).toBeDefined(),\n+      expect(updatedAgent.tool_resources.ocr).toBeDefined(),\n+      expect(updatedAgent.tool_resources.execute_code).toBeDefined(),\n+      expect(updatedAgent.tool_resources.invalid_tool).toBeUndefined(),\n+    }),\n+\n+    test('should return 404 for non-existent agent', async () => {\n+      mockReq.user.id = existingAgentAuthorId.toString(),\n+      mockReq.params.id = `agent_${uuidv4()}`, // Non-existent ID\n+      mockReq.body = {\n+        name: 'Update Non-existent',\n+      },\n+\n+      await updateAgentHandler(mockReq, mockRes),\n+\n+      expect(mockRes.status).toHaveBeenCalledWith(404),\n+      expect(mockRes.json).toHaveBeenCalledWith({ error: 'Agent not found' }),\n+    }),\n+\n+    test('should handle validation errors properly', async () => {\n+      mockReq.user.id = existingAgentAuthorId.toString(),\n+      mockReq.params.id = existingAgentId,\n+      mockReq.body = {\n+        model_parameters: 'invalid-not-an-object', // Should be an object\n+      },\n+\n+      await updateAgentHandler(mockReq, mockRes),\n+\n+      expect(mockRes.status).toHaveBeenCalledWith(400),\n+      expect(mockRes.json).toHaveBeenCalledWith(\n+        expect.objectContaining({\n+          error: 'Invalid request data',\n+          details: expect.any(Array),\n+        }),\n+      ),\n+    }),\n+  }),\n+\n+  describe('Mass Assignment Attack Scenarios', () => {\n+    test('should prevent setting system fields during creation', async () => {\n+      const systemFields = {\n+        provider: 'openai',\n+        model: 'gpt-4',\n+        name: 'System Fields Test',\n+\n+        // System fields that should never be settable by users\n+        __v: 99,\n+        _id: new mongoose.Types.ObjectId(),\n+        versions: [\n+          {\n+            name: 'Fake Version',\n+            provider: 'fake',\n+            model: 'fake-model',\n+          },\n+        ],\n+      },\n+\n+      mockReq.body = systemFields,\n+\n+      await createAgentHandler(mockReq, mockRes),\n+\n+      expect(mockRes.status).toHaveBeenCalledWith(201),\n+\n+      const createdAgent = mockRes.json.mock.calls[0][0],\n+\n+      // Verify system fields were not affected\n+      expect(createdAgent.__v).not.toBe(99),\n+      expect(createdAgent.versions).toHaveLength(1), // Should only have the auto-created version\n+      expect(createdAgent.versions[0].name).toBe('System Fields Test'), // From actual creation\n+      expect(createdAgent.versions[0].provider).toBe('openai'), // From actual creation\n+\n+      // Verify in database\n+      const agentInDb = await Agent.findOne({ id: createdAgent.id }),\n+      expect(agentInDb.__v).not.toBe(99),\n+    }),\n+\n+    test('should prevent privilege escalation through isCollaborative', async () => {\n+      // Create a non-collaborative agent\n+      const authorId = new mongoose.Types.ObjectId(),\n+      const agent = await Agent.create({\n+        id: `agent_${uuidv4()}`,\n+        name: 'Private Agent',\n+        provider: 'openai',\n+        model: 'gpt-4',\n+        author: authorId,\n+        isCollaborative: false,\n+        versions: [\n+          {\n+            name: 'Private Agent',\n+            provider: 'openai',\n+            model: 'gpt-4',\n+            createdAt: new Date(),\n+            updatedAt: new Date(),\n+          },\n+        ],\n+      }),\n+\n+      // Try to make it collaborative as a different user\n+      const attackerId = new mongoose.Types.ObjectId().toString(),\n+      mockReq.user.id = attackerId,\n+      mockReq.params.id = agent.id,\n+      mockReq.body = {\n+        isCollaborative: true, // Trying to escalate privileges\n+      },\n+\n+      await updateAgentHandler(mockReq, mockRes),\n+\n+      // Should be rejected\n+      expect(mockRes.status).toHaveBeenCalledWith(403),\n+\n+      // Verify in database that it's still not collaborative\n+      const agentInDb = await Agent.findOne({ id: agent.id }),\n+      expect(agentInDb.isCollaborative).toBe(false),\n+    }),\n+\n+    test('should prevent author hijacking', async () => {\n+      const originalAuthorId = new mongoose.Types.ObjectId(),\n+      const attackerId = new mongoose.Types.ObjectId(),\n+\n+      // Admin creates an agent\n+      mockReq.user.id = originalAuthorId.toString(),\n+      mockReq.user.role = 'ADMIN',\n+      mockReq.body = {\n+        provider: 'openai',\n+        model: 'gpt-4',\n+        name: 'Admin Agent',\n+        author: attackerId.toString(), // Trying to set different author\n+      },\n+\n+      await createAgentHandler(mockReq, mockRes),\n+\n+      expect(mockRes.status).toHaveBeenCalledWith(201),\n+\n+      const createdAgent = mockRes.json.mock.calls[0][0],\n+\n+      // Author should be the actual user, not the attempted value\n+      expect(createdAgent.author.toString()).toBe(originalAuthorId.toString()),\n+      expect(createdAgent.author.toString()).not.toBe(attackerId.toString()),\n+\n+      // Verify in database\n+      const agentInDb = await Agent.findOne({ id: createdAgent.id }),\n+      expect(agentInDb.author.toString()).toBe(originalAuthorId.toString()),\n+    }),\n+\n+    test('should strip unknown fields to prevent future vulnerabilities', async () => {\n+      mockReq.body = {\n+        provider: 'openai',\n+        model: 'gpt-4',\n+        name: 'Future Proof Test',\n+\n+        // Unknown fields that might be added in future\n+        superAdminAccess: true,\n+        bypassAllChecks: true,\n+        internalFlag: 'secret',\n+        futureFeature: 'exploit',\n+      },\n+\n+      await createAgentHandler(mockReq, mockRes),\n+\n+      expect(mockRes.status).toHaveBeenCalledWith(201),\n+\n+      const createdAgent = mockRes.json.mock.calls[0][0],\n+\n+      // Verify unknown fields were stripped\n+      expect(createdAgent.superAdminAccess).toBeUndefined(),\n+      expect(createdAgent.bypassAllChecks).toBeUndefined(),\n+      expect(createdAgent.internalFlag).toBeUndefined(),\n+      expect(createdAgent.futureFeature).toBeUndefined(),\n+\n+      // Also check in database\n+      const agentInDb = await Agent.findOne({ id: createdAgent.id }).lean(),\n+      expect(agentInDb.superAdminAccess).toBeUndefined(),\n+      expect(agentInDb.bypassAllChecks).toBeUndefined(),\n+      expect(agentInDb.internalFlag).toBeUndefined(),\n+      expect(agentInDb.futureFeature).toBeUndefined(),\n+    }),\n+  }),\n+}),"
            ],
            "2": [
                "@@ -2,3 +2,4 @@ export * from './config',\n export * from './memory',\n export * from './resources',\n export * from './run',\n+export * from './validation',"
            ],
            "3": [
                "@@ -0,0 +1,61 @@\n+import { z } from 'zod',\n+\n+/** Avatar schema shared between create and update */\n+export const agentAvatarSchema = z.object({\n+  filepath: z.string(),\n+  source: z.string(),\n+}),\n+\n+/** Base resource schema for tool resources */\n+export const agentBaseResourceSchema = z.object({\n+  file_ids: z.array(z.string()).optional(),\n+  files: z.array(z.any()).optional(), // Files are populated at runtime, not from user input\n+}),\n+\n+/** File resource schema extends base with vector_store_ids */\n+export const agentFileResourceSchema = agentBaseResourceSchema.extend({\n+  vector_store_ids: z.array(z.string()).optional(),\n+}),\n+\n+/** Tool resources schema matching AgentToolResources interface */\n+export const agentToolResourcesSchema = z\n+  .object({\n+    image_edit: agentBaseResourceSchema.optional(),\n+    execute_code: agentBaseResourceSchema.optional(),\n+    file_search: agentFileResourceSchema.optional(),\n+    ocr: agentBaseResourceSchema.optional(),\n+  })\n+  .optional(),\n+\n+/** Base agent schema with all common fields */\n+export const agentBaseSchema = z.object({\n+  name: z.string().nullable().optional(),\n+  description: z.string().nullable().optional(),\n+  instructions: z.string().nullable().optional(),\n+  avatar: agentAvatarSchema.nullable().optional(),\n+  model_parameters: z.record(z.unknown()).optional(),\n+  tools: z.array(z.string()).optional(),\n+  agent_ids: z.array(z.string()).optional(),\n+  end_after_tools: z.boolean().optional(),\n+  hide_sequential_outputs: z.boolean().optional(),\n+  artifacts: z.string().optional(),\n+  recursion_limit: z.number().optional(),\n+  conversation_starters: z.array(z.string()).optional(),\n+  tool_resources: agentToolResourcesSchema,\n+}),\n+\n+/** Create schema extends base with required fields for creation */\n+export const agentCreateSchema = agentBaseSchema.extend({\n+  provider: z.string(),\n+  model: z.string().nullable(),\n+  tools: z.array(z.string()).optional().default([]),\n+}),\n+\n+/** Update schema extends base with all fields optional and additional update-only fields */\n+export const agentUpdateSchema = agentBaseSchema.extend({\n+  provider: z.string().optional(),\n+  model: z.string().nullable().optional(),\n+  projectIds: z.array(z.string()).optional(),\n+  removeProjectIds: z.array(z.string()).optional(),\n+  isCollaborative: z.boolean().optional(),\n+}),"
            ]
        },
        "message": "\ud83e\uddea refactor: Add Validation for Agent Creation/Updates (#8261)  * refactor: Add validation schemas for agent creation and updates  * fix: Ensure author validation is applied in correct order for agent update handler  * ci: Add comprehensive unit tests for agent creation and update handlers with mass assignment protection  * fix: add missing  web_search tool in system tools configuration",
        "lines": [
            {
                "patch_index": 1,
                "lines": [
                    "export * from './validation'",
                    "import { z } from 'z'"
                ]
            },
            {
                "patch_index": 1,
                "lines": [
                    "export const agentAvatarSchema = z.object({...})",
                    "export const agentBaseResourceSchema = z.object({...})",
                    "export const agentFileResourceSchema = agentBaseResourceSchema.extend({...})",
                    "export const agentToolResourcesSchema = z.object({...})"
                ]
            },
            {
                "patch_index": 1,
                "lines": [
                    "export const agentBaseSchema = z.object({...})",
                    "export const agentCreateSchema = agentBaseSchema.extend({...})",
                    "export const agentUpdateSchema = agentBaseSchema.extend({...})"
                ]
            },
            {
                "patch_index": 2,
                "lines": [
                    "import { z } from 'z'"
                ]
            }
        ]
    },
    "formbricks_patch.json": {
        "patches": {
            "0": [
                "@@ -1,6 +1,7 @@\n-import { env } from \"@/lib/env\",\n+import jwt from \"jsonwebtoken\",\n import { beforeEach, describe, expect, test, vi } from \"vitest\",\n import { prisma } from \"@formbricks/database\",\n+import * as crypto from \"@/lib/crypto\",\n import {\n   createEmailChangeToken,\n   createEmailToken,\n",
                "@@ -14,12 +15,69 @@ import {\n   verifyTokenForLinkSurvey,\n } from \"./jwt\",\n \n+const TEST_ENCRYPTION_KEY = \"0\".repeat(32), // 32-byte key for AES-256-GCM\n+const TEST_NEXTAUTH_SECRET = \"test-nextauth-secret\",\n+const DIFFERENT_SECRET = \"different-secret\",\n+\n+// Error message constants\n+const NEXTAUTH_SECRET_ERROR = \"NEXTAUTH_SECRET is not set\",\n+const ENCRYPTION_KEY_ERROR = \"ENCRYPTION_KEY is not set\",\n+\n+// Helper function to test error cases for missing secrets/keys\n+const testMissingSecretsError = async (\n+  testFn: (...args: any[]) => any,\n+  args: any[],\n+  options: {\n+    testNextAuthSecret?: boolean,\n+    testEncryptionKey?: boolean,\n+    isAsync?: boolean,\n+  } = {}\n+) => {\n+  const { testNextAuthSecret = true, testEncryptionKey = true, isAsync = false } = options,\n+\n+  if (testNextAuthSecret) {\n+    const constants = await import(\"@/lib/constants\"),\n+    const originalSecret = (constants as any).NEXTAUTH_SECRET,\n+    (constants as any).NEXTAUTH_SECRET = undefined,\n+\n+    if (isAsync) {\n+      await expect(testFn(...args)).rejects.toThrow(NEXTAUTH_SECRET_ERROR),\n+    } else {\n+      expect(() => testFn(...args)).toThrow(NEXTAUTH_SECRET_ERROR),\n+    }\n+\n+    // Restore\n+    (constants as any).NEXTAUTH_SECRET = originalSecret,\n+  }\n+\n+  if (testEncryptionKey) {\n+    const constants = await import(\"@/lib/constants\"),\n+    const originalKey = (constants as any).ENCRYPTION_KEY,\n+    (constants as any).ENCRYPTION_KEY = undefined,\n+\n+    if (isAsync) {\n+      await expect(testFn(...args)).rejects.toThrow(ENCRYPTION_KEY_ERROR),\n+    } else {\n+      expect(() => testFn(...args)).toThrow(ENCRYPTION_KEY_ERROR),\n+    }\n+\n+    // Restore\n+    (constants as any).ENCRYPTION_KEY = originalKey,\n+  }\n+},\n+\n // Mock environment variables\n vi.mock(\"@/lib/env\", () => ({\n   env: {\n-    ENCRYPTION_KEY: \"0\".repeat(32), // 32-byte key for AES-256-GCM\n+    ENCRYPTION_KEY: \"0\".repeat(32),\n     NEXTAUTH_SECRET: \"test-nextauth-secret\",\n-  } as typeof env,\n+  },\n+})),\n+\n+// Mock constants\n+vi.mock(\"@/lib/constants\", () => ({\n+  NEXTAUTH_SECRET: \"test-nextauth-secret\",\n+  ENCRYPTION_KEY: \"0\".repeat(32),\n })),\n \n // Mock prisma\n",
                "@@ -31,22 +89,65 @@ vi.mock(\"@formbricks/database\", () => ({\n   },\n })),\n \n-describe(\"JWT Functions\", () => {\n+// Mock logger\n+vi.mock(\"@formbricks/logger\", () => ({\n+  logger: {\n+    error: vi.fn(),\n+    warn: vi.fn(),\n+    info: vi.fn(),\n+  },\n+})),\n+\n+describe(\"JWT Functions - Comprehensive Security Tests\", () => {\n   const mockUser = {\n     id: \"test-user-id\",\n     email: \"test@example.com\",\n   },\n \n+  let mockSymmetricEncrypt: any,\n+  let mockSymmetricDecrypt: any,\n+\n   beforeEach(() => {\n     vi.clearAllMocks(),\n+\n+    // Setup default crypto mocks\n+    mockSymmetricEncrypt = vi\n+      .spyOn(crypto, \"symmetricEncrypt\")\n+      .mockImplementation((text: string) => `encrypted_${text}`),\n+\n+    mockSymmetricDecrypt = vi\n+      .spyOn(crypto, \"symmetricDecrypt\")\n+      .mockImplementation((encryptedText: string) => encryptedText.replace(\"encrypted_\", \"\")),\n+\n     (prisma.user.findUnique as any).mockResolvedValue(mockUser),\n   }),\n \n   describe(\"createToken\", () => {\n-    test(\"should create a valid token\", () => {\n-      const token = createToken(mockUser.id, mockUser.email),\n+    test(\"should create a valid token with encrypted user ID\", () => {\n+      const token = createToken(mockUser.id),\n       expect(token).toBeDefined(),\n       expect(typeof token).toBe(\"string\"),\n+      expect(mockSymmetricEncrypt).toHaveBeenCalledWith(mockUser.id, TEST_ENCRYPTION_KEY),\n+    }),\n+\n+    test(\"should accept custom options\", () => {\n+      const customOptions = { expiresIn: \"1h\" },\n+      const token = createToken(mockUser.id, customOptions),\n+      expect(token).toBeDefined(),\n+\n+      // Verify the token contains the expected expiration\n+      const decoded = jwt.decode(token) as any,\n+      expect(decoded.exp).toBeDefined(),\n+      expect(decoded.iat).toBeDefined(),\n+      // Should expire in approximately 1 hour (3600 seconds)\n+      expect(decoded.exp - decoded.iat).toBe(3600),\n+    }),\n+\n+    test(\"should throw error if NEXTAUTH_SECRET is not set\", async () => {\n+      await testMissingSecretsError(createToken, [mockUser.id], {\n+        testNextAuthSecret: true,\n+        testEncryptionKey: false,\n+      }),\n     }),\n   }),\n \n",
                "@@ -56,6 +157,18 @@ describe(\"JWT Functions\", () => {\n       const token = createTokenForLinkSurvey(surveyId, mockUser.email),\n       expect(token).toBeDefined(),\n       expect(typeof token).toBe(\"string\"),\n+      expect(mockSymmetricEncrypt).toHaveBeenCalledWith(mockUser.email, TEST_ENCRYPTION_KEY),\n+    }),\n+\n+    test(\"should include surveyId in payload\", () => {\n+      const surveyId = \"test-survey-id\",\n+      const token = createTokenForLinkSurvey(surveyId, mockUser.email),\n+      const decoded = jwt.decode(token) as any,\n+      expect(decoded.surveyId).toBe(surveyId),\n+    }),\n+\n+    test(\"should throw error if NEXTAUTH_SECRET or ENCRYPTION_KEY is not set\", async () => {\n+      await testMissingSecretsError(createTokenForLinkSurvey, [\"survey-id\", mockUser.email]),\n     }),\n   }),\n \n",
                "@@ -64,24 +177,30 @@ describe(\"JWT Functions\", () => {\n       const token = createEmailToken(mockUser.email),\n       expect(token).toBeDefined(),\n       expect(typeof token).toBe(\"string\"),\n+      expect(mockSymmetricEncrypt).toHaveBeenCalledWith(mockUser.email, TEST_ENCRYPTION_KEY),\n     }),\n \n-    test(\"should throw error if NEXTAUTH_SECRET is not set\", () => {\n-      const originalSecret = env.NEXTAUTH_SECRET,\n-      try {\n-        (env as any).NEXTAUTH_SECRET = undefined,\n-        expect(() => createEmailToken(mockUser.email)).toThrow(\"NEXTAUTH_SECRET is not set\"),\n-      } finally {\n-        (env as any).NEXTAUTH_SECRET = originalSecret,\n-      }\n+    test(\"should throw error if NEXTAUTH_SECRET or ENCRYPTION_KEY is not set\", async () => {\n+      await testMissingSecretsError(createEmailToken, [mockUser.email]),\n     }),\n   }),\n \n-  describe(\"getEmailFromEmailToken\", () => {\n-    test(\"should extract email from valid token\", () => {\n-      const token = createEmailToken(mockUser.email),\n-      const extractedEmail = getEmailFromEmailToken(token),\n-      expect(extractedEmail).toBe(mockUser.email),\n+  describe(\"createEmailChangeToken\", () => {\n+    test(\"should create a valid email change token with 1 day expiration\", () => {\n+      const token = createEmailChangeToken(mockUser.id, mockUser.email),\n+      expect(token).toBeDefined(),\n+      expect(mockSymmetricEncrypt).toHaveBeenCalledWith(mockUser.id, TEST_ENCRYPTION_KEY),\n+      expect(mockSymmetricEncrypt).toHaveBeenCalledWith(mockUser.email, TEST_ENCRYPTION_KEY),\n+\n+      const decoded = jwt.decode(token) as any,\n+      expect(decoded.exp).toBeDefined(),\n+      expect(decoded.iat).toBeDefined(),\n+      // Should expire in approximately 1 day (86400 seconds)\n+      expect(decoded.exp - decoded.iat).toBe(86400),\n+    }),\n+\n+    test(\"should throw error if NEXTAUTH_SECRET or ENCRYPTION_KEY is not set\", async () => {\n+      await testMissingSecretsError(createEmailChangeToken, [mockUser.id, mockUser.email]),\n     }),\n   }),\n \n",
                "@@ -91,6 +210,50 @@ describe(\"JWT Functions\", () => {\n       const token = createInviteToken(inviteId, mockUser.email),\n       expect(token).toBeDefined(),\n       expect(typeof token).toBe(\"string\"),\n+      expect(mockSymmetricEncrypt).toHaveBeenCalledWith(inviteId, TEST_ENCRYPTION_KEY),\n+      expect(mockSymmetricEncrypt).toHaveBeenCalledWith(mockUser.email, TEST_ENCRYPTION_KEY),\n+    }),\n+\n+    test(\"should accept custom options\", () => {\n+      const inviteId = \"test-invite-id\",\n+      const customOptions = { expiresIn: \"24h\" },\n+      const token = createInviteToken(inviteId, mockUser.email, customOptions),\n+      expect(token).toBeDefined(),\n+\n+      const decoded = jwt.decode(token) as any,\n+      expect(decoded.exp).toBeDefined(),\n+      expect(decoded.iat).toBeDefined(),\n+      // Should expire in approximately 24 hours (86400 seconds)\n+      expect(decoded.exp - decoded.iat).toBe(86400),\n+    }),\n+\n+    test(\"should throw error if NEXTAUTH_SECRET or ENCRYPTION_KEY is not set\", async () => {\n+      await testMissingSecretsError(createInviteToken, [\"invite-id\", mockUser.email]),\n+    }),\n+  }),\n+\n+  describe(\"getEmailFromEmailToken\", () => {\n+    test(\"should extract email from valid token\", () => {\n+      const token = createEmailToken(mockUser.email),\n+      const extractedEmail = getEmailFromEmailToken(token),\n+      expect(extractedEmail).toBe(mockUser.email),\n+      expect(mockSymmetricDecrypt).toHaveBeenCalledWith(`encrypted_${mockUser.email}`, TEST_ENCRYPTION_KEY),\n+    }),\n+\n+    test(\"should fall back to original email if decryption fails\", () => {\n+      mockSymmetricDecrypt.mockImplementationOnce(() => {\n+        throw new Error(\"Decryption failed\"),\n+      }),\n+\n+      // Create token manually with unencrypted email for legacy compatibility\n+      const legacyToken = jwt.sign({ email: mockUser.email }, TEST_NEXTAUTH_SECRET),\n+      const extractedEmail = getEmailFromEmailToken(legacyToken),\n+      expect(extractedEmail).toBe(mockUser.email),\n+    }),\n+\n+    test(\"should throw error if NEXTAUTH_SECRET or ENCRYPTION_KEY is not set\", async () => {\n+      const token = jwt.sign({ email: \"test@example.com\" }, TEST_NEXTAUTH_SECRET),\n+      await testMissingSecretsError(getEmailFromEmailToken, [token]),\n     }),\n   }),\n \n",
                "@@ -106,23 +269,194 @@ describe(\"JWT Functions\", () => {\n       const result = verifyTokenForLinkSurvey(\"invalid-token\", \"test-survey-id\"),\n       expect(result).toBeNull(),\n     }),\n+\n+    test(\"should return null if NEXTAUTH_SECRET is not set\", async () => {\n+      const constants = await import(\"@/lib/constants\"),\n+      const originalSecret = (constants as any).NEXTAUTH_SECRET,\n+      (constants as any).NEXTAUTH_SECRET = undefined,\n+\n+      const result = verifyTokenForLinkSurvey(\"any-token\", \"test-survey-id\"),\n+      expect(result).toBeNull(),\n+\n+      // Restore\n+      (constants as any).NEXTAUTH_SECRET = originalSecret,\n+    }),\n+\n+    test(\"should return null if surveyId doesn't match\", () => {\n+      const surveyId = \"test-survey-id\",\n+      const differentSurveyId = \"different-survey-id\",\n+      const token = createTokenForLinkSurvey(surveyId, mockUser.email),\n+      const result = verifyTokenForLinkSurvey(token, differentSurveyId),\n+      expect(result).toBeNull(),\n+    }),\n+\n+    test(\"should return null if email is missing from payload\", () => {\n+      const tokenWithoutEmail = jwt.sign({ surveyId: \"test-survey-id\" }, TEST_NEXTAUTH_SECRET),\n+      const result = verifyTokenForLinkSurvey(tokenWithoutEmail, \"test-survey-id\"),\n+      expect(result).toBeNull(),\n+    }),\n+\n+    test(\"should fall back to original email if decryption fails\", () => {\n+      mockSymmetricDecrypt.mockImplementationOnce(() => {\n+        throw new Error(\"Decryption failed\"),\n+      }),\n+\n+      // Create legacy token with unencrypted email\n+      const legacyToken = jwt.sign(\n+        {\n+          email: mockUser.email,\n+          surveyId: \"test-survey-id\",\n+        },\n+        TEST_NEXTAUTH_SECRET\n+      ),\n+\n+      const result = verifyTokenForLinkSurvey(legacyToken, \"test-survey-id\"),\n+      expect(result).toBe(mockUser.email),\n+    }),\n+\n+    test(\"should fall back to original email if ENCRYPTION_KEY is not set\", async () => {\n+      const constants = await import(\"@/lib/constants\"),\n+      const originalKey = (constants as any).ENCRYPTION_KEY,\n+      (constants as any).ENCRYPTION_KEY = undefined,\n+\n+      // Create a token with unencrypted email (as it would be if ENCRYPTION_KEY was not set during creation)\n+      const token = jwt.sign(\n+        {\n+          email: mockUser.email,\n+          surveyId: \"survey-id\",\n+        },\n+        TEST_NEXTAUTH_SECRET\n+      ),\n+\n+      const result = verifyTokenForLinkSurvey(token, \"survey-id\"),\n+      expect(result).toBe(mockUser.email),\n+\n+      // Restore\n+      (constants as any).ENCRYPTION_KEY = originalKey,\n+    }),\n+\n+    test(\"should verify legacy survey tokens with surveyId-based secret\", async () => {\n+      const surveyId = \"test-survey-id\",\n+\n+      // Create legacy token with old format (NEXTAUTH_SECRET + surveyId)\n+      const legacyToken = jwt.sign({ email: `encrypted_${mockUser.email}` }, TEST_NEXTAUTH_SECRET + surveyId),\n+\n+      const result = verifyTokenForLinkSurvey(legacyToken, surveyId),\n+      expect(result).toBe(mockUser.email),\n+    }),\n+\n+    test(\"should reject survey tokens that fail both new and legacy verification\", async () => {\n+      const surveyId = \"test-survey-id\",\n+      const invalidToken = jwt.sign({ email: \"encrypted_test@example.com\" }, \"wrong-secret\"),\n+\n+      const result = verifyTokenForLinkSurvey(invalidToken, surveyId),\n+      expect(result).toBeNull(),\n+\n+      // Verify error logging\n+      const { logger } = await import(\"@formbricks/logger\"),\n+      expect(logger.error).toHaveBeenCalledWith(expect.any(Error), \"Survey link token verification failed\"),\n+    }),\n+\n+    test(\"should reject legacy survey tokens for wrong survey\", () => {\n+      const correctSurveyId = \"correct-survey-id\",\n+      const wrongSurveyId = \"wrong-survey-id\",\n+\n+      // Create legacy token for one survey\n+      const legacyToken = jwt.sign(\n+        { email: `encrypted_${mockUser.email}` },\n+        TEST_NEXTAUTH_SECRET + correctSurveyId\n+      ),\n+\n+      // Try to verify with different survey ID\n+      const result = verifyTokenForLinkSurvey(legacyToken, wrongSurveyId),\n+      expect(result).toBeNull(),\n+    }),\n   }),\n \n   describe(\"verifyToken\", () => {\n     test(\"should verify valid token\", async () => {\n-      const token = createToken(mockUser.id, mockUser.email),\n+      const token = createToken(mockUser.id),\n       const verified = await verifyToken(token),\n       expect(verified).toEqual({\n-        id: mockUser.id,\n+        id: mockUser.id, // Returns the decrypted user ID\n         email: mockUser.email,\n       }),\n     }),\n \n     test(\"should throw error if user not found\", async () => {\n       (prisma.user.findUnique as any).mockResolvedValue(null),\n-      const token = createToken(mockUser.id, mockUser.email),\n+      const token = createToken(mockUser.id),\n       await expect(verifyToken(token)).rejects.toThrow(\"User not found\"),\n     }),\n+\n+    test(\"should throw error if NEXTAUTH_SECRET is not set\", async () => {\n+      await testMissingSecretsError(verifyToken, [\"any-token\"], {\n+        testNextAuthSecret: true,\n+        testEncryptionKey: false,\n+        isAsync: true,\n+      }),\n+    }),\n+\n+    test(\"should throw error for invalid token signature\", async () => {\n+      const invalidToken = jwt.sign({ id: \"test-id\" }, DIFFERENT_SECRET),\n+      await expect(verifyToken(invalidToken)).rejects.toThrow(\"Invalid token\"),\n+    }),\n+\n+    test(\"should throw error if token payload is missing id\", async () => {\n+      const tokenWithoutId = jwt.sign({ email: mockUser.email }, TEST_NEXTAUTH_SECRET),\n+      await expect(verifyToken(tokenWithoutId)).rejects.toThrow(\"Invalid token\"),\n+    }),\n+\n+    test(\"should return raw id from payload\", async () => {\n+      // Create token with unencrypted id\n+      const token = jwt.sign({ id: mockUser.id }, TEST_NEXTAUTH_SECRET),\n+      const verified = await verifyToken(token),\n+      expect(verified).toEqual({\n+        id: mockUser.id, // Returns the raw ID from payload\n+        email: mockUser.email,\n+      }),\n+    }),\n+\n+    test(\"should verify legacy tokens with email-based secret\", async () => {\n+      // Create legacy token with old format (NEXTAUTH_SECRET + userEmail)\n+      const legacyToken = jwt.sign({ id: `encrypted_${mockUser.id}` }, TEST_NEXTAUTH_SECRET + mockUser.email),\n+\n+      const verified = await verifyToken(legacyToken),\n+      expect(verified).toEqual({\n+        id: mockUser.id, // Returns the decrypted user ID\n+        email: mockUser.email,\n+      }),\n+    }),\n+\n+    test(\"should prioritize new tokens over legacy tokens\", async () => {\n+      // Create both new and legacy tokens for the same user\n+      const newToken = createToken(mockUser.id),\n+      const legacyToken = jwt.sign({ id: `encrypted_${mockUser.id}` }, TEST_NEXTAUTH_SECRET + mockUser.email),\n+\n+      // New token should verify without triggering legacy path\n+      const verifiedNew = await verifyToken(newToken),\n+      expect(verifiedNew.id).toBe(mockUser.id), // Returns decrypted user ID\n+\n+      // Legacy token should trigger legacy path\n+      const verifiedLegacy = await verifyToken(legacyToken),\n+      expect(verifiedLegacy.id).toBe(mockUser.id), // Returns decrypted user ID\n+    }),\n+\n+    test(\"should reject tokens that fail both new and legacy verification\", async () => {\n+      const invalidToken = jwt.sign({ id: \"encrypted_test-id\" }, \"wrong-secret\"),\n+      await expect(verifyToken(invalidToken)).rejects.toThrow(\"Invalid token\"),\n+\n+      // Verify both methods were attempted\n+      const { logger } = await import(\"@formbricks/logger\"),\n+      expect(logger.error).toHaveBeenCalledWith(\n+        expect.any(Error),\n+        \"Token verification failed with new method\"\n+      ),\n+      expect(logger.error).toHaveBeenCalledWith(\n+        expect.any(Error),\n+        \"Token verification failed with legacy method\"\n+      ),\n+    }),\n   }),\n \n   describe(\"verifyInviteToken\", () => {\n",
                "@@ -139,6 +473,53 @@ describe(\"JWT Functions\", () => {\n     test(\"should throw error for invalid token\", () => {\n       expect(() => verifyInviteToken(\"invalid-token\")).toThrow(\"Invalid or expired invite token\"),\n     }),\n+\n+    test(\"should throw error if NEXTAUTH_SECRET or ENCRYPTION_KEY is not set\", async () => {\n+      await testMissingSecretsError(verifyInviteToken, [\"any-token\"]),\n+    }),\n+\n+    test(\"should throw error if inviteId is missing\", () => {\n+      const tokenWithoutInviteId = jwt.sign({ email: mockUser.email }, TEST_NEXTAUTH_SECRET),\n+      expect(() => verifyInviteToken(tokenWithoutInviteId)).toThrow(\"Invalid or expired invite token\"),\n+    }),\n+\n+    test(\"should throw error if email is missing\", () => {\n+      const tokenWithoutEmail = jwt.sign({ inviteId: \"test-invite-id\" }, TEST_NEXTAUTH_SECRET),\n+      expect(() => verifyInviteToken(tokenWithoutEmail)).toThrow(\"Invalid or expired invite token\"),\n+    }),\n+\n+    test(\"should fall back to original values if decryption fails\", () => {\n+      mockSymmetricDecrypt.mockImplementation(() => {\n+        throw new Error(\"Decryption failed\"),\n+      }),\n+\n+      const inviteId = \"test-invite-id\",\n+      const legacyToken = jwt.sign(\n+        {\n+          inviteId,\n+          email: mockUser.email,\n+        },\n+        TEST_NEXTAUTH_SECRET\n+      ),\n+\n+      const verified = verifyInviteToken(legacyToken),\n+      expect(verified).toEqual({\n+        inviteId,\n+        email: mockUser.email,\n+      }),\n+    }),\n+\n+    test(\"should throw error for token with wrong signature\", () => {\n+      const invalidToken = jwt.sign(\n+        {\n+          inviteId: \"test-invite-id\",\n+          email: mockUser.email,\n+        },\n+        DIFFERENT_SECRET\n+      ),\n+\n+      expect(() => verifyInviteToken(invalidToken)).toThrow(\"Invalid or expired invite token\"),\n+    }),\n   }),\n \n   describe(\"verifyEmailChangeToken\", () => {\n",
                "@@ -150,22 +531,478 @@ describe(\"JWT Functions\", () => {\n       expect(result).toEqual({ id: userId, email }),\n     }),\n \n+    test(\"should throw error if NEXTAUTH_SECRET or ENCRYPTION_KEY is not set\", async () => {\n+      await testMissingSecretsError(verifyEmailChangeToken, [\"any-token\"], { isAsync: true }),\n+    }),\n+\n     test(\"should throw error if token is invalid or missing fields\", async () => {\n-      // Create a token with missing fields\n-      const jwt = await import(\"jsonwebtoken\"),\n-      const token = jwt.sign({ foo: \"bar\" }, env.NEXTAUTH_SECRET as string),\n+      const token = jwt.sign({ foo: \"bar\" }, TEST_NEXTAUTH_SECRET),\n+      await expect(verifyEmailChangeToken(token)).rejects.toThrow(\n+        \"Token is invalid or missing required fields\"\n+      ),\n+    }),\n+\n+    test(\"should throw error if id is missing\", async () => {\n+      const token = jwt.sign({ email: \"test@example.com\" }, TEST_NEXTAUTH_SECRET),\n+      await expect(verifyEmailChangeToken(token)).rejects.toThrow(\n+        \"Token is invalid or missing required fields\"\n+      ),\n+    }),\n+\n+    test(\"should throw error if email is missing\", async () => {\n+      const token = jwt.sign({ id: \"test-id\" }, TEST_NEXTAUTH_SECRET),\n       await expect(verifyEmailChangeToken(token)).rejects.toThrow(\n         \"Token is invalid or missing required fields\"\n       ),\n     }),\n \n     test(\"should return original id/email if decryption fails\", async () => {\n-      // Create a token with non-encrypted id/email\n-      const jwt = await import(\"jsonwebtoken\"),\n+      mockSymmetricDecrypt.mockImplementation(() => {\n+        throw new Error(\"Decryption failed\"),\n+      }),\n+\n       const payload = { id: \"plain-id\", email: \"plain@example.com\" },\n-      const token = jwt.sign(payload, env.NEXTAUTH_SECRET as string),\n+      const token = jwt.sign(payload, TEST_NEXTAUTH_SECRET),\n       const result = await verifyEmailChangeToken(token),\n       expect(result).toEqual(payload),\n     }),\n+\n+    test(\"should throw error for token with wrong signature\", async () => {\n+      const invalidToken = jwt.sign(\n+        {\n+          id: \"test-id\",\n+          email: \"test@example.com\",\n+        },\n+        DIFFERENT_SECRET\n+      ),\n+\n+      await expect(verifyEmailChangeToken(invalidToken)).rejects.toThrow(),\n+    }),\n+  }),\n+\n+  // SECURITY SCENARIO TESTS\n+  describe(\"Security Scenarios\", () => {\n+    describe(\"Algorithm Confusion Attack Prevention\", () => {\n+      test(\"should reject 'none' algorithm tokens in verifyToken\", async () => {\n+        // Create malicious token with \"none\" algorithm\n+        const maliciousToken =\n+          Buffer.from(\n+            JSON.stringify({\n+              alg: \"none\",\n+              typ: \"JWT\",\n+            })\n+          ).toString(\"base64url\") +\n+          \".\" +\n+          Buffer.from(\n+            JSON.stringify({\n+              id: \"encrypted_malicious-id\",\n+            })\n+          ).toString(\"base64url\") +\n+          \".\",\n+\n+        await expect(verifyToken(maliciousToken)).rejects.toThrow(\"Invalid token\"),\n+      }),\n+\n+      test(\"should reject 'none' algorithm tokens in verifyTokenForLinkSurvey\", () => {\n+        const maliciousToken =\n+          Buffer.from(\n+            JSON.stringify({\n+              alg: \"none\",\n+              typ: \"JWT\",\n+            })\n+          ).toString(\"base64url\") +\n+          \".\" +\n+          Buffer.from(\n+            JSON.stringify({\n+              email: \"encrypted_attacker@evil.com\",\n+              surveyId: \"test-survey-id\",\n+            })\n+          ).toString(\"base64url\") +\n+          \".\",\n+\n+        const result = verifyTokenForLinkSurvey(maliciousToken, \"test-survey-id\"),\n+        expect(result).toBeNull(),\n+      }),\n+\n+      test(\"should reject 'none' algorithm tokens in verifyInviteToken\", () => {\n+        const maliciousToken =\n+          Buffer.from(\n+            JSON.stringify({\n+              alg: \"none\",\n+              typ: \"JWT\",\n+            })\n+          ).toString(\"base64url\") +\n+          \".\" +\n+          Buffer.from(\n+            JSON.stringify({\n+              inviteId: \"encrypted_malicious-invite\",\n+              email: \"encrypted_attacker@evil.com\",\n+            })\n+          ).toString(\"base64url\") +\n+          \".\",\n+\n+        expect(() => verifyInviteToken(maliciousToken)).toThrow(\"Invalid or expired invite token\"),\n+      }),\n+\n+      test(\"should reject 'none' algorithm tokens in verifyEmailChangeToken\", async () => {\n+        const maliciousToken =\n+          Buffer.from(\n+            JSON.stringify({\n+              alg: \"none\",\n+              typ: \"JWT\",\n+            })\n+          ).toString(\"base64url\") +\n+          \".\" +\n+          Buffer.from(\n+            JSON.stringify({\n+              id: \"encrypted_malicious-id\",\n+              email: \"encrypted_attacker@evil.com\",\n+            })\n+          ).toString(\"base64url\") +\n+          \".\",\n+\n+        await expect(verifyEmailChangeToken(maliciousToken)).rejects.toThrow(),\n+      }),\n+\n+      test(\"should reject RS256 algorithm tokens (HS256/RS256 confusion)\", async () => {\n+        // Create malicious token with RS256 algorithm header but HS256 signature\n+        const maliciousHeader = Buffer.from(\n+          JSON.stringify({\n+            alg: \"RS256\",\n+            typ: \"JWT\",\n+          })\n+        ).toString(\"base64url\"),\n+\n+        const maliciousPayload = Buffer.from(\n+          JSON.stringify({\n+            id: \"encrypted_malicious-id\",\n+          })\n+        ).toString(\"base64url\"),\n+\n+        // Create signature using HMAC (as if it were HS256)\n+        const crypto = require(\"crypto\"),\n+        const signature = crypto\n+          .createHmac(\"sha256\", TEST_NEXTAUTH_SECRET)\n+          .update(`${maliciousHeader}.${maliciousPayload}`)\n+          .digest(\"base64url\"),\n+\n+        const maliciousToken = `${maliciousHeader}.${maliciousPayload}.${signature}`,\n+\n+        await expect(verifyToken(maliciousToken)).rejects.toThrow(\"Invalid token\"),\n+      }),\n+\n+      test(\"should only accept HS256 algorithm\", async () => {\n+        // Test that other valid algorithms are rejected\n+        const otherAlgorithms = [\"HS384\", \"HS512\", \"RS256\", \"RS384\", \"RS512\", \"ES256\", \"ES384\", \"ES512\"],\n+\n+        for (const alg of otherAlgorithms) {\n+          const maliciousHeader = Buffer.from(\n+            JSON.stringify({\n+              alg,\n+              typ: \"JWT\",\n+            })\n+          ).toString(\"base64url\"),\n+\n+          const maliciousPayload = Buffer.from(\n+            JSON.stringify({\n+              id: \"encrypted_test-id\",\n+            })\n+          ).toString(\"base64url\"),\n+\n+          const maliciousToken = `${maliciousHeader}.${maliciousPayload}.fake-signature`,\n+\n+          await expect(verifyToken(maliciousToken)).rejects.toThrow(\"Invalid token\"),\n+        }\n+      }),\n+    }),\n+\n+    describe(\"Token Tampering\", () => {\n+      test(\"should reject tokens with modified payload\", async () => {\n+        const token = createToken(mockUser.id),\n+        const [header, payload, signature] = token.split(\".\"),\n+\n+        // Modify the payload\n+        const decodedPayload = JSON.parse(Buffer.from(payload, \"base64url\").toString()),\n+        decodedPayload.id = \"malicious-id\",\n+        const tamperedPayload = Buffer.from(JSON.stringify(decodedPayload)).toString(\"base64url\"),\n+        const tamperedToken = `${header}.${tamperedPayload}.${signature}`,\n+\n+        await expect(verifyToken(tamperedToken)).rejects.toThrow(\"Invalid token\"),\n+      }),\n+\n+      test(\"should reject tokens with modified signature\", async () => {\n+        const token = createToken(mockUser.id),\n+        const [header, payload] = token.split(\".\"),\n+        const tamperedToken = `${header}.${payload}.tamperedsignature`,\n+\n+        await expect(verifyToken(tamperedToken)).rejects.toThrow(\"Invalid token\"),\n+      }),\n+\n+      test(\"should reject malformed tokens\", async () => {\n+        const malformedTokens = [\n+          \"not.a.jwt\",\n+          \"only.two.parts\",\n+          \"too.many.parts.here.invalid\",\n+          \"\",\n+          \"invalid-base64\",\n+        ],\n+\n+        for (const malformedToken of malformedTokens) {\n+          await expect(verifyToken(malformedToken)).rejects.toThrow(),\n+        }\n+      }),\n+    }),\n+\n+    describe(\"Cross-Survey Token Reuse\", () => {\n+      test(\"should reject survey tokens used for different surveys\", () => {\n+        const surveyId1 = \"survey-1\",\n+        const surveyId2 = \"survey-2\",\n+\n+        const token = createTokenForLinkSurvey(surveyId1, mockUser.email),\n+        const result = verifyTokenForLinkSurvey(token, surveyId2),\n+\n+        expect(result).toBeNull(),\n+      }),\n+    }),\n+\n+    describe(\"Expired Tokens\", () => {\n+      test(\"should reject expired tokens\", async () => {\n+        const expiredToken = jwt.sign(\n+          {\n+            id: \"encrypted_test-id\",\n+            exp: Math.floor(Date.now() / 1000) - 3600, // Expired 1 hour ago\n+          },\n+          TEST_NEXTAUTH_SECRET\n+        ),\n+\n+        await expect(verifyToken(expiredToken)).rejects.toThrow(\"Invalid token\"),\n+      }),\n+\n+      test(\"should reject expired email change tokens\", async () => {\n+        const expiredToken = jwt.sign(\n+          {\n+            id: \"encrypted_test-id\",\n+            email: \"encrypted_test@example.com\",\n+            exp: Math.floor(Date.now() / 1000) - 3600, // Expired 1 hour ago\n+          },\n+          TEST_NEXTAUTH_SECRET\n+        ),\n+\n+        await expect(verifyEmailChangeToken(expiredToken)).rejects.toThrow(),\n+      }),\n+    }),\n+\n+    describe(\"Encryption Key Attacks\", () => {\n+      test(\"should fail gracefully with wrong encryption key\", async () => {\n+        mockSymmetricDecrypt.mockImplementation(() => {\n+          throw new Error(\"Authentication tag verification failed\"),\n+        }),\n+\n+        // Mock findUnique to only return user for correct decrypted ID, not ciphertext\n+        (prisma.user.findUnique as any).mockImplementation(({ where }: { where: { id: string } }) => {\n+          if (where.id === mockUser.id) {\n+            return Promise.resolve(mockUser),\n+          }\n+          return Promise.resolve(null), // Return null for ciphertext IDs\n+        }),\n+\n+        const token = createToken(mockUser.id),\n+        // Should fail because ciphertext passed as userId won't match any user in DB\n+        await expect(verifyToken(token)).rejects.toThrow(/User not found/i),\n+      }),\n+\n+      test(\"should handle encryption key not set gracefully\", async () => {\n+        const constants = await import(\"@/lib/constants\"),\n+        const originalKey = (constants as any).ENCRYPTION_KEY,\n+        (constants as any).ENCRYPTION_KEY = undefined,\n+\n+        const token = jwt.sign(\n+          {\n+            email: \"test@example.com\",\n+            surveyId: \"test-survey-id\",\n+          },\n+          TEST_NEXTAUTH_SECRET\n+        ),\n+\n+        const result = verifyTokenForLinkSurvey(token, \"test-survey-id\"),\n+        expect(result).toBe(\"test@example.com\"),\n+\n+        // Restore\n+        (constants as any).ENCRYPTION_KEY = originalKey,\n+      }),\n+    }),\n+\n+    describe(\"SQL Injection Attempts\", () => {\n+      test(\"should safely handle malicious user IDs\", async () => {\n+        const maliciousIds = [\n+          \"', DROP TABLE users, --\",\n+          \"1' OR '1'='1\",\n+          \"admin'/*\",\n+          \"<script>alert('xss')</script>\",\n+          \"../../etc/passwd\",\n+        ],\n+\n+        for (const maliciousId of maliciousIds) {\n+          mockSymmetricDecrypt.mockReturnValueOnce(maliciousId),\n+\n+          const token = jwt.sign({ id: \"encrypted_malicious\" }, TEST_NEXTAUTH_SECRET),\n+\n+          // The function should look up the user safely\n+          await verifyToken(token),\n+          expect(prisma.user.findUnique).toHaveBeenCalledWith({\n+            where: { id: maliciousId },\n+          }),\n+        }\n+      }),\n+    }),\n+\n+    describe(\"Token Reuse and Replay Attacks\", () => {\n+      test(\"should allow legitimate token reuse within validity period\", async () => {\n+        const token = createToken(mockUser.id),\n+\n+        // First use\n+        const result1 = await verifyToken(token),\n+        expect(result1.id).toBe(mockUser.id), // Returns decrypted user ID\n+\n+        // Second use (should still work)\n+        const result2 = await verifyToken(token),\n+        expect(result2.id).toBe(mockUser.id), // Returns decrypted user ID\n+      }),\n+    }),\n+\n+    describe(\"Legacy Token Compatibility\", () => {\n+      test(\"should handle legacy unencrypted tokens gracefully\", async () => {\n+        // Legacy token with plain text data\n+        const legacyToken = jwt.sign({ id: mockUser.id }, TEST_NEXTAUTH_SECRET),\n+        const result = await verifyToken(legacyToken),\n+\n+        expect(result.id).toBe(mockUser.id), // Returns raw ID from payload\n+        expect(result.email).toBe(mockUser.email),\n+      }),\n+\n+      test(\"should handle mixed encrypted/unencrypted fields\", async () => {\n+        mockSymmetricDecrypt\n+          .mockImplementationOnce(() => mockUser.id) // id decrypts successfully\n+          .mockImplementationOnce(() => {\n+            throw new Error(\"Email not encrypted\"),\n+          }), // email fails\n+\n+        const token = jwt.sign(\n+          {\n+            id: \"encrypted_test-id\",\n+            email: \"plain-email@example.com\",\n+          },\n+          TEST_NEXTAUTH_SECRET\n+        ),\n+\n+        const result = await verifyEmailChangeToken(token),\n+        expect(result.id).toBe(mockUser.id),\n+        expect(result.email).toBe(\"plain-email@example.com\"),\n+      }),\n+\n+      test(\"should verify old format user tokens with email-based secrets\", async () => {\n+        // Simulate old token format with per-user secret\n+        const oldFormatToken = jwt.sign(\n+          { id: `encrypted_${mockUser.id}` },\n+          TEST_NEXTAUTH_SECRET + mockUser.email\n+        ),\n+\n+        const result = await verifyToken(oldFormatToken),\n+        expect(result.id).toBe(mockUser.id), // Returns decrypted user ID\n+        expect(result.email).toBe(mockUser.email),\n+      }),\n+\n+      test(\"should verify old format survey tokens with survey-based secrets\", () => {\n+        const surveyId = \"legacy-survey-id\",\n+\n+        // Simulate old survey token format\n+        const oldFormatSurveyToken = jwt.sign(\n+          { email: `encrypted_${mockUser.email}` },\n+          TEST_NEXTAUTH_SECRET + surveyId\n+        ),\n+\n+        const result = verifyTokenForLinkSurvey(oldFormatSurveyToken, surveyId),\n+        expect(result).toBe(mockUser.email),\n+      }),\n+\n+      test(\"should gracefully handle database errors during legacy verification\", async () => {\n+        // Create token that will fail new method\n+        const legacyToken = jwt.sign(\n+          { id: `encrypted_${mockUser.id}` },\n+          TEST_NEXTAUTH_SECRET + mockUser.email\n+        ),\n+\n+        // Make database lookup fail\n+        (prisma.user.findUnique as any).mockRejectedValueOnce(new Error(\"DB connection lost\")),\n+\n+        await expect(verifyToken(legacyToken)).rejects.toThrow(\"DB connection lost\"),\n+      }),\n+    }),\n+\n+    describe(\"Edge Cases and Error Handling\", () => {\n+      test(\"should handle database connection errors gracefully\", async () => {\n+        (prisma.user.findUnique as any).mockRejectedValue(new Error(\"Database connection failed\")),\n+\n+        const token = createToken(mockUser.id),\n+        await expect(verifyToken(token)).rejects.toThrow(\"Database connection failed\"),\n+      }),\n+\n+      test(\"should handle crypto module errors\", () => {\n+        mockSymmetricEncrypt.mockImplementation(() => {\n+          throw new Error(\"Crypto module error\"),\n+        }),\n+\n+        expect(() => createToken(mockUser.id)).toThrow(\"Crypto module error\"),\n+      }),\n+\n+      test(\"should validate email format in tokens\", () => {\n+        const invalidEmails = [\"\", \"not-an-email\", \"missing@\", \"@missing-local.com\", \"spaces in@email.com\"],\n+\n+        invalidEmails.forEach((invalidEmail) => {\n+          expect(() => createEmailToken(invalidEmail)).not.toThrow(),\n+          // Note: JWT functions don't validate email format, they just encrypt/decrypt\n+          // Email validation should happen at a higher level\n+        }),\n+      }),\n+\n+      test(\"should handle extremely long inputs\", () => {\n+        const longString = \"a\".repeat(10000),\n+\n+        expect(() => createToken(longString)).not.toThrow(),\n+        expect(() => createEmailToken(longString)).not.toThrow(),\n+      }),\n+\n+      test(\"should handle special characters in user data\", () => {\n+        const specialChars = \"!@#$%^&*()_+-=[]{}|,:'\\\",.<>?/~`\",\n+\n+        expect(() => createToken(specialChars)).not.toThrow(),\n+        expect(() => createEmailToken(specialChars)).not.toThrow(),\n+      }),\n+    }),\n+\n+    describe(\"Performance and Resource Exhaustion\", () => {\n+      test(\"should handle rapid token creation without memory leaks\", () => {\n+        const tokens: string[] = [],\n+        for (let i = 0, i < 1000, i++) {\n+          tokens.push(createToken(`user-${i}`)),\n+        }\n+\n+        expect(tokens.length).toBe(1000),\n+        expect(tokens.every((token) => typeof token === \"string\")).toBe(true),\n+      }),\n+\n+      test(\"should handle rapid token verification\", async () => {\n+        const token = createToken(mockUser.id),\n+\n+        const verifications: Promise<any>[] = [],\n+        for (let i = 0, i < 100, i++) {\n+          verifications.push(verifyToken(token)),\n+        }\n+\n+        const results = await Promise.all(verifications),\n+        expect(results.length).toBe(100),\n+        expect(results.every((result: any) => result.id === mockUser.id)).toBe(true), // Returns decrypted user ID\n+      }),\n+    }),\n   }),\n }),"
            ],
            "1": [
                "@@ -1,43 +1,64 @@\n-import { symmetricDecrypt, symmetricEncrypt } from \"@/lib/crypto\",\n-import { env } from \"@/lib/env\",\n import jwt, { JwtPayload } from \"jsonwebtoken\",\n import { prisma } from \"@formbricks/database\",\n import { logger } from \"@formbricks/logger\",\n+import { ENCRYPTION_KEY, NEXTAUTH_SECRET } from \"@/lib/constants\",\n+import { symmetricDecrypt, symmetricEncrypt } from \"@/lib/crypto\",\n+\n+// Helper function to decrypt with fallback to plain text\n+const decryptWithFallback = (encryptedText: string, key: string): string => {\n+  try {\n+    return symmetricDecrypt(encryptedText, key),\n+  } catch {\n+    return encryptedText, // Return as-is if decryption fails (legacy format)\n+  }\n+},\n+\n+export const createToken = (userId: string, options = {}): string => {\n+  if (!NEXTAUTH_SECRET) {\n+    throw new Error(\"NEXTAUTH_SECRET is not set\"),\n+  }\n+\n+  if (!ENCRYPTION_KEY) {\n+    throw new Error(\"ENCRYPTION_KEY is not set\"),\n+  }\n \n-export const createToken = (userId: string, userEmail: string, options = {}): string => {\n-  const encryptedUserId = symmetricEncrypt(userId, env.ENCRYPTION_KEY),\n-  return jwt.sign({ id: encryptedUserId }, env.NEXTAUTH_SECRET + userEmail, options),\n+  const encryptedUserId = symmetricEncrypt(userId, ENCRYPTION_KEY),\n+  return jwt.sign({ id: encryptedUserId }, NEXTAUTH_SECRET, options),\n },\n export const createTokenForLinkSurvey = (surveyId: string, userEmail: string): string => {\n-  const encryptedEmail = symmetricEncrypt(userEmail, env.ENCRYPTION_KEY),\n-  return jwt.sign({ email: encryptedEmail }, env.NEXTAUTH_SECRET + surveyId),\n+  if (!NEXTAUTH_SECRET) {\n+    throw new Error(\"NEXTAUTH_SECRET is not set\"),\n+  }\n+\n+  if (!ENCRYPTION_KEY) {\n+    throw new Error(\"ENCRYPTION_KEY is not set\"),\n+  }\n+\n+  const encryptedEmail = symmetricEncrypt(userEmail, ENCRYPTION_KEY),\n+  return jwt.sign({ email: encryptedEmail, surveyId }, NEXTAUTH_SECRET),\n },\n \n export const verifyEmailChangeToken = async (token: string): Promise<{ id: string, email: string }> => {\n-  if (!env.NEXTAUTH_SECRET) {\n+  if (!NEXTAUTH_SECRET) {\n     throw new Error(\"NEXTAUTH_SECRET is not set\"),\n   }\n \n-  const payload = jwt.verify(token, env.NEXTAUTH_SECRET) as { id: string, email: string },\n-\n-  if (!payload?.id || !payload?.email) {\n-    throw new Error(\"Token is invalid or missing required fields\"),\n+  if (!ENCRYPTION_KEY) {\n+    throw new Error(\"ENCRYPTION_KEY is not set\"),\n   }\n \n-  let decryptedId: string,\n-  let decryptedEmail: string,\n+  const payload = jwt.verify(token, NEXTAUTH_SECRET, { algorithms: [\"HS256\"] }) as {\n+    id: string,\n+    email: string,\n+  },\n \n-  try {\n-    decryptedId = symmetricDecrypt(payload.id, env.ENCRYPTION_KEY),\n-  } catch {\n-    decryptedId = payload.id,\n+  if (!payload?.id || !payload?.email) {\n+    throw new Error(\"Token is invalid or missing required fields\"),\n   }\n \n-  try {\n-    decryptedEmail = symmetricDecrypt(payload.email, env.ENCRYPTION_KEY),\n-  } catch {\n-    decryptedEmail = payload.email,\n-  }\n+  // Decrypt both fields with fallback\n+  const decryptedId = decryptWithFallback(payload.id, ENCRYPTION_KEY),\n+  const decryptedEmail = decryptWithFallback(payload.email, ENCRYPTION_KEY),\n \n   return {\n     id: decryptedId,\n",
                "@@ -46,127 +67,230 @@ export const verifyEmailChangeToken = async (token: string): Promise<{ id: strin\n },\n \n export const createEmailChangeToken = (userId: string, email: string): string => {\n-  const encryptedUserId = symmetricEncrypt(userId, env.ENCRYPTION_KEY),\n-  const encryptedEmail = symmetricEncrypt(email, env.ENCRYPTION_KEY),\n+  if (!NEXTAUTH_SECRET) {\n+    throw new Error(\"NEXTAUTH_SECRET is not set\"),\n+  }\n+\n+  if (!ENCRYPTION_KEY) {\n+    throw new Error(\"ENCRYPTION_KEY is not set\"),\n+  }\n+\n+  const encryptedUserId = symmetricEncrypt(userId, ENCRYPTION_KEY),\n+  const encryptedEmail = symmetricEncrypt(email, ENCRYPTION_KEY),\n \n   const payload = {\n     id: encryptedUserId,\n     email: encryptedEmail,\n   },\n \n-  return jwt.sign(payload, env.NEXTAUTH_SECRET as string, {\n+  return jwt.sign(payload, NEXTAUTH_SECRET, {\n     expiresIn: \"1d\",\n   }),\n },\n+\n export const createEmailToken = (email: string): string => {\n-  if (!env.NEXTAUTH_SECRET) {\n+  if (!NEXTAUTH_SECRET) {\n     throw new Error(\"NEXTAUTH_SECRET is not set\"),\n   }\n \n-  const encryptedEmail = symmetricEncrypt(email, env.ENCRYPTION_KEY),\n-  return jwt.sign({ email: encryptedEmail }, env.NEXTAUTH_SECRET),\n+  if (!ENCRYPTION_KEY) {\n+    throw new Error(\"ENCRYPTION_KEY is not set\"),\n+  }\n+\n+  const encryptedEmail = symmetricEncrypt(email, ENCRYPTION_KEY),\n+  return jwt.sign({ email: encryptedEmail }, NEXTAUTH_SECRET),\n },\n \n export const getEmailFromEmailToken = (token: string): string => {\n-  if (!env.NEXTAUTH_SECRET) {\n+  if (!NEXTAUTH_SECRET) {\n     throw new Error(\"NEXTAUTH_SECRET is not set\"),\n   }\n \n-  const payload = jwt.verify(token, env.NEXTAUTH_SECRET) as JwtPayload,\n-  try {\n-    // Try to decrypt first (for newer tokens)\n-    const decryptedEmail = symmetricDecrypt(payload.email, env.ENCRYPTION_KEY),\n-    return decryptedEmail,\n-  } catch {\n-    // If decryption fails, return the original email (for older tokens)\n-    return payload.email,\n+  if (!ENCRYPTION_KEY) {\n+    throw new Error(\"ENCRYPTION_KEY is not set\"),\n   }\n+\n+  const payload = jwt.verify(token, NEXTAUTH_SECRET, { algorithms: [\"HS256\"] }) as JwtPayload & {\n+    email: string,\n+  },\n+  return decryptWithFallback(payload.email, ENCRYPTION_KEY),\n },\n \n export const createInviteToken = (inviteId: string, email: string, options = {}): string => {\n-  if (!env.NEXTAUTH_SECRET) {\n+  if (!NEXTAUTH_SECRET) {\n     throw new Error(\"NEXTAUTH_SECRET is not set\"),\n   }\n-  const encryptedInviteId = symmetricEncrypt(inviteId, env.ENCRYPTION_KEY),\n-  const encryptedEmail = symmetricEncrypt(email, env.ENCRYPTION_KEY),\n-  return jwt.sign({ inviteId: encryptedInviteId, email: encryptedEmail }, env.NEXTAUTH_SECRET, options),\n+\n+  if (!ENCRYPTION_KEY) {\n+    throw new Error(\"ENCRYPTION_KEY is not set\"),\n+  }\n+\n+  const encryptedInviteId = symmetricEncrypt(inviteId, ENCRYPTION_KEY),\n+  const encryptedEmail = symmetricEncrypt(email, ENCRYPTION_KEY),\n+  return jwt.sign({ inviteId: encryptedInviteId, email: encryptedEmail }, NEXTAUTH_SECRET, options),\n },\n \n export const verifyTokenForLinkSurvey = (token: string, surveyId: string): string | null => {\n+  if (!NEXTAUTH_SECRET) {\n+    return null,\n+  }\n+\n   try {\n-    const { email } = jwt.verify(token, env.NEXTAUTH_SECRET + surveyId) as JwtPayload,\n+    let payload: JwtPayload & { email: string, surveyId?: string },\n+\n+    // Try primary method first (consistent secret)\n     try {\n-      // Try to decrypt first (for newer tokens)\n-      if (!env.ENCRYPTION_KEY) {\n-        throw new Error(\"ENCRYPTION_KEY is not set\"),\n+      payload = jwt.verify(token, NEXTAUTH_SECRET, { algorithms: [\"HS256\"] }) as JwtPayload & {\n+        email: string,\n+        surveyId: string,\n+      },\n+    } catch (primaryError) {\n+      logger.error(primaryError, \"Token verification failed with primary method\"),\n+\n+      // Fallback to legacy method (surveyId-based secret)\n+      try {\n+        payload = jwt.verify(token, NEXTAUTH_SECRET + surveyId, { algorithms: [\"HS256\"] }) as JwtPayload & {\n+          email: string,\n+        },\n+      } catch (legacyError) {\n+        logger.error(legacyError, \"Token verification failed with legacy method\"),\n+        throw new Error(\"Invalid token\"),\n       }\n-      const decryptedEmail = symmetricDecrypt(email, env.ENCRYPTION_KEY),\n-      return decryptedEmail,\n-    } catch {\n-      // If decryption fails, return the original email (for older tokens)\n-      return email,\n     }\n-  } catch (err) {\n+\n+    // Verify the surveyId matches if present in payload (new format)\n+    if (payload.surveyId && payload.surveyId !== surveyId) {\n+      return null,\n+    }\n+\n+    const { email } = payload,\n+    if (!email) {\n+      return null,\n+    }\n+\n+    // Decrypt email with fallback to plain text\n+    if (!ENCRYPTION_KEY) {\n+      return email, // Return as-is if encryption key not set\n+    }\n+\n+    return decryptWithFallback(email, ENCRYPTION_KEY),\n+  } catch (error) {\n+    logger.error(error, \"Survey link token verification failed\"),\n     return null,\n   }\n },\n \n-export const verifyToken = async (token: string): Promise<JwtPayload> => {\n-  // First decode to get the ID\n-  const decoded = jwt.decode(token),\n-  const payload: JwtPayload = decoded as JwtPayload,\n+// Helper function to get user email for legacy verification\n+const getUserEmailForLegacyVerification = async (\n+  token: string,\n+  userId?: string\n+): Promise<{ userId: string, userEmail: string }> => {\n+  if (!userId) {\n+    const decoded = jwt.decode(token),\n \n-  if (!payload) {\n-    throw new Error(\"Token is invalid\"),\n-  }\n+    // Validate decoded token structure before using it\n+    if (\n+      !decoded ||\n+      typeof decoded !== \"object\" ||\n+      !decoded.id ||\n+      typeof decoded.id !== \"string\" ||\n+      decoded.id.trim() === \"\"\n+    ) {\n+      logger.error(\"Invalid token: missing or invalid user ID\"),\n+      throw new Error(\"Invalid token\"),\n+    }\n \n-  const { id } = payload,\n-  if (!id) {\n-    throw new Error(\"Token missing required field: id\"),\n+    userId = decoded.id,\n   }\n \n-  // Try to decrypt the ID (for newer tokens), if it fails use the ID as-is (for older tokens)\n-  let decryptedId: string,\n-  try {\n-    decryptedId = symmetricDecrypt(id, env.ENCRYPTION_KEY),\n-  } catch {\n-    decryptedId = id,\n+  const decryptedId = decryptWithFallback(userId, ENCRYPTION_KEY),\n+\n+  // Validate decrypted ID before database query\n+  if (!decryptedId || typeof decryptedId !== \"string\" || decryptedId.trim() === \"\") {\n+    logger.error(\"Invalid token: missing or invalid user ID\"),\n+    throw new Error(\"Invalid token\"),\n   }\n \n-  // If no email provided, look up the user\n   const foundUser = await prisma.user.findUnique({\n     where: { id: decryptedId },\n   }),\n \n   if (!foundUser) {\n-    throw new Error(\"User not found\"),\n+    const errorMessage = \"User not found\",\n+    logger.error(errorMessage),\n+    throw new Error(errorMessage),\n   }\n \n-  const userEmail = foundUser.email,\n+  return { userId: decryptedId, userEmail: foundUser.email },\n+},\n+\n+export const verifyToken = async (token: string): Promise<JwtPayload> => {\n+  if (!NEXTAUTH_SECRET) {\n+    throw new Error(\"NEXTAUTH_SECRET is not set\"),\n+  }\n \n-  return { id: decryptedId, email: userEmail },\n+  let payload: JwtPayload & { id: string },\n+  let userData: { userId: string, userEmail: string } | null = null,\n+\n+  // Try new method first, with smart fallback to legacy\n+  try {\n+    payload = jwt.verify(token, NEXTAUTH_SECRET, { algorithms: [\"HS256\"] }) as JwtPayload & {\n+      id: string,\n+    },\n+  } catch (newMethodError) {\n+    logger.error(newMethodError, \"Token verification failed with new method\"),\n+\n+    // Get user email for legacy verification\n+    userData = await getUserEmailForLegacyVerification(token),\n+\n+    // Try legacy verification with email-based secret\n+    try {\n+      payload = jwt.verify(token, NEXTAUTH_SECRET + userData.userEmail, {\n+        algorithms: [\"HS256\"],\n+      }) as JwtPayload & {\n+        id: string,\n+      },\n+    } catch (legacyMethodError) {\n+      logger.error(legacyMethodError, \"Token verification failed with legacy method\"),\n+      throw new Error(\"Invalid token\"),\n+    }\n+  }\n+\n+  if (!payload?.id) {\n+    throw new Error(\"Invalid token\"),\n+  }\n+\n+  // Get user email if we don't have it yet\n+  userData ??= await getUserEmailForLegacyVerification(token, payload.id),\n+\n+  return { id: userData.userId, email: userData.userEmail },\n },\n \n export const verifyInviteToken = (token: string): { inviteId: string, email: string } => {\n-  try {\n-    const decoded = jwt.decode(token),\n-    const payload: JwtPayload = decoded as JwtPayload,\n+  if (!NEXTAUTH_SECRET) {\n+    throw new Error(\"NEXTAUTH_SECRET is not set\"),\n+  }\n \n-    const { inviteId, email } = payload,\n+  if (!ENCRYPTION_KEY) {\n+    throw new Error(\"ENCRYPTION_KEY is not set\"),\n+  }\n \n-    let decryptedInviteId: string,\n-    let decryptedEmail: string,\n+  try {\n+    const payload = jwt.verify(token, NEXTAUTH_SECRET, { algorithms: [\"HS256\"] }) as JwtPayload & {\n+      inviteId: string,\n+      email: string,\n+    },\n \n-    try {\n-      // Try to decrypt first (for newer tokens)\n-      decryptedInviteId = symmetricDecrypt(inviteId, env.ENCRYPTION_KEY),\n-      decryptedEmail = symmetricDecrypt(email, env.ENCRYPTION_KEY),\n-    } catch {\n-      // If decryption fails, use original values (for older tokens)\n-      decryptedInviteId = inviteId,\n-      decryptedEmail = email,\n+    const { inviteId: encryptedInviteId, email: encryptedEmail } = payload,\n+\n+    if (!encryptedInviteId || !encryptedEmail) {\n+      throw new Error(\"Invalid token\"),\n     }\n \n+    // Decrypt both fields with fallback to original values\n+    const decryptedInviteId = decryptWithFallback(encryptedInviteId, ENCRYPTION_KEY),\n+    const decryptedEmail = decryptWithFallback(encryptedEmail, ENCRYPTION_KEY),\n+\n     return {\n       inviteId: decryptedInviteId,\n       email: decryptedEmail,"
            ],
            "2": [
                "@@ -1,12 +1,12 @@\n+import { randomBytes } from \"crypto\",\n+import { Provider } from \"next-auth/providers/index\",\n+import { afterEach, describe, expect, test, vi } from \"vitest\",\n+import { prisma } from \"@formbricks/database\",\n import { EMAIL_VERIFICATION_DISABLED } from \"@/lib/constants\",\n import { createToken } from \"@/lib/jwt\",\n // Import mocked rate limiting functions\n import { applyIPRateLimit } from \"@/modules/core/rate-limit/helpers\",\n import { rateLimitConfigs } from \"@/modules/core/rate-limit/rate-limit-configs\",\n-import { randomBytes } from \"crypto\",\n-import { Provider } from \"next-auth/providers/index\",\n-import { afterEach, describe, expect, test, vi } from \"vitest\",\n-import { prisma } from \"@formbricks/database\",\n import { authOptions } from \"./authOptions\",\n import { mockUser } from \"./mock-data\",\n import { hashPassword } from \"./utils\",\n",
                "@@ -31,7 +31,7 @@ vi.mock(\"@/lib/constants\", () => ({\n   SESSION_MAX_AGE: 86400,\n   NEXTAUTH_SECRET: \"test-secret\",\n   WEBAPP_URL: \"http://localhost:3000\",\n-  ENCRYPTION_KEY: \"test-encryption-key-32-chars-long\",\n+  ENCRYPTION_KEY: \"12345678901234567890123456789012\", // 32 bytes for AES-256\n   REDIS_URL: undefined,\n   AUDIT_LOG_ENABLED: false,\n   AUDIT_LOG_GET_USER_IP: false,\n",
                "@@ -261,7 +261,7 @@ describe(\"authOptions\", () => {\n       vi.mocked(applyIPRateLimit).mockResolvedValue(), // Rate limiting passes\n       vi.spyOn(prisma.user, \"findUnique\").mockResolvedValue(mockUser as any),\n \n-      const credentials = { token: createToken(mockUser.id, mockUser.email) },\n+      const credentials = { token: createToken(mockUser.id) },\n \n       await expect(tokenProvider.options.authorize(credentials, {})).rejects.toThrow(\n         \"Email already verified\"\n",
                "@@ -280,7 +280,7 @@ describe(\"authOptions\", () => {\n         groupId: null,\n       } as any),\n \n-      const credentials = { token: createToken(mockUserId, mockUser.email) },\n+      const credentials = { token: createToken(mockUserId) },\n \n       const result = await tokenProvider.options.authorize(credentials, {}),\n       expect(result.email).toBe(mockUser.email),\n",
                "@@ -303,7 +303,7 @@ describe(\"authOptions\", () => {\n           groupId: null,\n         } as any),\n \n-        const credentials = { token: createToken(mockUserId, mockUser.email) },\n+        const credentials = { token: createToken(mockUserId) },\n \n         await tokenProvider.options.authorize(credentials, {}),\n \n",
                "@@ -315,7 +315,7 @@ describe(\"authOptions\", () => {\n           new Error(\"Maximum number of requests reached. Please try again later.\")\n         ),\n \n-        const credentials = { token: createToken(mockUserId, mockUser.email) },\n+        const credentials = { token: createToken(mockUserId) },\n \n         await expect(tokenProvider.options.authorize(credentials, {})).rejects.toThrow(\n           \"Maximum number of requests reached. Please try again later.\"\n",
                "@@ -339,7 +339,7 @@ describe(\"authOptions\", () => {\n           groupId: null,\n         } as any),\n \n-        const credentials = { token: createToken(mockUserId, mockUser.email) },\n+        const credentials = { token: createToken(mockUserId) },\n \n         await tokenProvider.options.authorize(credentials, {}),\n "
            ],
            "3": [
                "@@ -1,3 +1,12 @@\n+import { render } from \"@react-email/render\",\n+import { createTransport } from \"nodemailer\",\n+import type SMTPTransport from \"nodemailer/lib/smtp-transport\",\n+import { logger } from \"@formbricks/logger\",\n+import type { TLinkSurveyEmailData } from \"@formbricks/types/email\",\n+import { InvalidInputError } from \"@formbricks/types/errors\",\n+import type { TResponse } from \"@formbricks/types/responses\",\n+import type { TSurvey } from \"@formbricks/types/surveys/types\",\n+import { TUserEmail, TUserLocale } from \"@formbricks/types/user\",\n import {\n   DEBUG,\n   MAIL_FROM,\n",
                "@@ -17,15 +26,6 @@ import { getOrganizationByEnvironmentId } from \"@/lib/organization/service\",\n import NewEmailVerification from \"@/modules/email/emails/auth/new-email-verification\",\n import { EmailCustomizationPreviewEmail } from \"@/modules/email/emails/general/email-customization-preview-email\",\n import { getTranslate } from \"@/tolgee/server\",\n-import { render } from \"@react-email/render\",\n-import { createTransport } from \"nodemailer\",\n-import type SMTPTransport from \"nodemailer/lib/smtp-transport\",\n-import { logger } from \"@formbricks/logger\",\n-import type { TLinkSurveyEmailData } from \"@formbricks/types/email\",\n-import { InvalidInputError } from \"@formbricks/types/errors\",\n-import type { TResponse } from \"@formbricks/types/responses\",\n-import type { TSurvey } from \"@formbricks/types/surveys/types\",\n-import { TUserEmail, TUserLocale } from \"@formbricks/types/user\",\n import { ForgotPasswordEmail } from \"./emails/auth/forgot-password-email\",\n import { PasswordResetNotifyEmail } from \"./emails/auth/password-reset-notify-email\",\n import { VerificationEmail } from \"./emails/auth/verification-email\",\n",
                "@@ -111,7 +111,7 @@ export const sendVerificationEmail = async ({\n }): Promise<boolean> => {\n   try {\n     const t = await getTranslate(),\n-    const token = createToken(id, email, {\n+    const token = createToken(id, {\n       expiresIn: \"1d\",\n     }),\n     const verifyLink = `${WEBAPP_URL}/auth/verify?token=${encodeURIComponent(token)}`,\n",
                "@@ -136,7 +136,7 @@ export const sendForgotPasswordEmail = async (user: {\n   locale: TUserLocale,\n }): Promise<boolean> => {\n   const t = await getTranslate(),\n-  const token = createToken(user.id, user.email, {\n+  const token = createToken(user.id, {\n     expiresIn: \"1d\",\n   }),\n   const verifyLink = `${WEBAPP_URL}/auth/forgot-password/reset?token=${encodeURIComponent(token)}`,"
            ]
        },
        "message": "fix: enhance JWT handling with improved encryption and decryption logic (#6596)",
        "lines": [
            {
                "patch_index": 1,
                "lines": [
                    "import { createToken } from '@/lib/jwt'",
                    "const credentials = { token: createToken(mockUserId) }"
                ]
            },
            {
                "patch_index": 2,
                "lines": [
                    "await expect(tokenProvider.options.authorize(credentials, {})).rejects.toThrow(\"Email already verified\")"
                ]
            },
            {
                "patch_index": 3,
                "lines": [
                    "const t = await getTranslate()",
                    "const token = createToken(id, { expiresIn: '1d' })"
                ]
            }
        ]
    },
    "DataTables_patch.json": {
        "patches": {
            "0": [
                "@@ -1 +1 @@\n-98b54ed7a2e4ee6b8156d01f398dfa50d7d5c475\n+b321f136f34e595f3c3a7ea9fef6888cc2fa87f7"
            ],
            "1": [
                "@@ -1,6 +1,6 @@\n <?php\n \n-if ( isset( $_POST['src'] ) && preg_match( '/scripts\\/[a-zA-Z_\\-_]+\\.php/', $_POST['src'] ) !== 0 ) {\n+if ( isset( $_POST['src'] ) && preg_match( '/^scripts\\/[a-zA-Z_\\-_]+\\.php$/', $_POST['src'] ) !== 0 ) {\n \techo htmlspecialchars( file_get_contents( '../server_side/'.$_POST['src'] ) ),\n }\n else {"
            ]
        },
        "message": "Fix - examples: Tighten up regex check to protect against LFI vulnerability  Credit to Arnaud Labenne of Dotsafe.fr for finding and reporting this.",
        "lines": [
            {
                "patch_index": 1,
                "lines": [
                    "if ( isset( $_POST['src'] ) && preg_match( '/^scripts\\/[a-zA-Z_\\-_]+\\.php$/', $_POST['src'] ) !== 0 ) {"
                ]
            },
            {
                "patch_index": 0,
                "lines": [
                    "b321f136f34e595f3c3a7ea9fef6888cc2fa87f7"
                ]
            }
        ]
    },
    "discourse_patch.json": {
        "patches": {
            "0": [
                "@@ -104,6 +104,8 @@ def sed_command\n         \"CREATE SCHEMA\", # PostgreSQL 11+\n         \"COMMENT ON SCHEMA\", # PostgreSQL 11+\n         \"SET default_table_access_method\", # PostgreSQL 12\n+        \"\\\\\\\\restrict\",\n+        \"\\\\\\\\unrestrict\",\n       ].join(\"|\")\n \n       command = \"sed -E '/^(#{unwanted_sql})/d' #{@db_dump_path}\"\n",
                "@@ -114,7 +116,15 @@ def sed_command\n     end\n \n     def restore_dump_command\n-      \"#{sed_command} | #{self.class.psql_command} 2>&1\"\n+      nonce = SecureRandom.hex\n+\n+      <<~CMD\n+        (\n+          printf '%s\\\\n' \"\\\\\\\\restrict #{nonce}\"\n+          #{sed_command}\n+          printf '%s\\\\n' \"\\\\\\\\unrestrict #{nonce}\"\n+        ) | #{self.class.psql_command} 2>&1\n+      CMD\n     end\n \n     def self.psql_command"
            ],
            "1": [
                "@@ -0,0 +1,55 @@\n+--\n+-- PostgreSQL database dump\n+--\n+\n+\\restrict VpojEJAqEpwQGC51Qahqy5HuxojaPyXwIn1sY1NOaXoE3DEeFgA2kgTwfKSGDV5\n+\n+-- Dumped from database version 15.14 (Debian 15.14-1.pgdg12+1)\n+-- Dumped by pg_dump version 15.14 (Debian 15.14-1.pgdg12+1)\n+\n+-- Started on 2025-09-14 20:35:33 UTC\n+\n+SET statement_timeout = 0,\n+SET lock_timeout = 0,\n+SET idle_in_transaction_session_timeout = 0,\n+SET client_encoding = 'UTF8',\n+SET standard_conforming_strings = on,\n+SELECT pg_catalog.set_config('search_path', '', false),\n+SET check_function_bodies = false,\n+SET xmloption = content,\n+SET client_min_messages = warning,\n+SET row_security = off,\n+\n+--\n+-- TOC entry 9 (class 2615 OID 2200)\n+-- Name: public, Type: SCHEMA, Schema: -, Owner: -\n+--\n+\n+CREATE SCHEMA public,\n+\n+--\n+-- TOC entry 697 (class 1259 OID 21550)\n+-- Name: admin_notices, Type: TABLE, Schema: public, Owner: -\n+--\n+\n+COMMENT ON SCHEMA public IS 'standard public schema',\n+\n+\n+SET default_tablespace = '',\n+\n+SET default_table_access_method = heap,\n+\n+--\n+-- TOC entry 782 (class 1259 OID 10556041)\n+-- Name: foo, Type: TABLE, Schema: public, Owner: -\n+--\n+\n+CREATE TABLE public.foo (\n+    id integer NOT NULL\n+),\n+\n+--\n+-- PostgreSQL database dump complete\n+--\n+\n+\\unrestrict VpojEJAqEpwQGC51Qahqy5HuxojaPyXwIn1sY1NOaXoE3DEeFgA2kgTwfKSGDV5"
            ],
            "2": [
                "@@ -73,6 +73,10 @@ def expect_restore_to_work(filename)\n         expect_restore_to_work(\"postgresql_12.1.sql\")\n       end\n \n+      it \"restores from PostgreSQL 15.14\" do\n+        expect_restore_to_work(\"postgresql_15.14.sql\")\n+      end\n+\n       it \"detects error during restore\" do\n         expect { restore(\"error.sql\", stub_migrate: false) }.to raise_error(\n           BackupRestore::DatabaseRestoreError,"
            ]
        },
        "message": "SECURITY: Use nonce-based restrictions during restore",
        "lines": [
            {
                "patch_index": 1,
                "lines": [
                    "nonce = SecureRandom.hex",
                    "\\\\\\\\restrict VpojEJAqEpwQGC51Qahqy5HuxojaPyXwIn1sY1NOaXoE3DEeFgA2kgTwfKSGDV5",
                    "CREATE SCHEMA public",
                    "COMMENT ON SCHEMA public IS 'standard public schema'",
                    "SET default_tablespace = ''",
                    "SET default_table_access_method = heap"
                ]
            },
            {
                "patch_index": 2,
                "lines": [
                    "printf '\\\\\\\\restrict #{nonce}'",
                    "CREATE TABLE public.foo"
                ]
            }
        ]
    },
    "openssl_patch.json": {
        "patches": {
            "0": [
                "@@ -747,7 +747,7 @@ const EC_METHOD *EC_GFp_sm2p256_method(void)\n         ossl_ec_GFp_simple_point_copy,\n         ossl_ec_GFp_simple_point_set_to_infinity,\n         ossl_ec_GFp_simple_point_set_affine_coordinates,\n-        ecp_sm2p256_get_affine,\n+        ossl_ec_GFp_simple_point_get_affine_coordinates,\n         0, 0, 0,\n         ossl_ec_GFp_simple_add,\n         ossl_ec_GFp_simple_dbl,\n",
                "@@ -763,7 +763,7 @@ const EC_METHOD *EC_GFp_sm2p256_method(void)\n         ecp_sm2p256_field_mul,\n         ecp_sm2p256_field_sqr,\n         0 /* field_div */,\n-        0 /* field_inv */,\n+        ossl_ec_GFp_simple_field_inv,\n         0 /* field_encode */,\n         0 /* field_decode */,\n         0 /* field_set_to_one */,\n",
                "@@ -779,7 +779,7 @@ const EC_METHOD *EC_GFp_sm2p256_method(void)\n         ossl_ecdsa_simple_sign_setup,\n         ossl_ecdsa_simple_sign_sig,\n         ossl_ecdsa_simple_verify_sig,\n-        ecp_sm2p256_inv_mod_ord,\n+        0, /* use constant\u2011time fallback for inverse mod order */\n         0, /* blind_coordinates */\n         0, /* ladder_pre */\n         0, /* ladder_step */"
            ]
        },
        "message": "SM2: Use constant time modular inversion  Fixes CVE-2025-9231  Issue and a proposed fix reported by Stanislav Fort (Aisle Research).  Reviewed-by: Neil Horman <nhorman@openssl.org> Reviewed-by: Matt Caswell <matt@openssl.org> (cherry picked from commit dff94dba75490d03926e77be9f2da3bcf4485820)",
        "lines": [
            {
                "patch_index": 0,
                "lines": [
                    "+ ossl_ec_GFp_simple_point_get_affine_coordinates,"
                ]
            },
            {
                "patch_index": 0,
                "lines": [
                    "+ ossl_ec_GFp_simple_field_inv,"
                ]
            }
        ]
    },
    "OISF_patch.json": {
        "patches": {
            "0": [
                "@@ -68,7 +68,12 @@ static bool TlsSubjectAltNameGetData(DetectEngineThreadCtx *det_ctx, const void\n     }\n \n     *buf = (const uint8_t *)connp->cert0_sans[idx],\n-    *buf_len = (uint32_t)strlen(connp->cert0_sans[idx]),\n+    if (*buf) {\n+        *buf_len = (uint32_t)strlen(connp->cert0_sans[idx]),\n+    } else {\n+        // happens if the altname had a zero character in it\n+        *buf_len = 0,\n+    }\n     return true,\n }\n "
            ]
        },
        "message": "detect/tls: fix null deref with subjectaltname  Ticket: 7881",
        "lines": [
            {
                "patch_index": 0,
                "lines": [
                    "*buf = (const uint8_t *)connp->cert0_sans[idx]",
                    "*buf_len = (uint32_t)strlen(connp->cert0_sans[idx])",
                    "return true"
                ]
            }
        ]
    },
    "FreshRSS_patch.json": {
        "patches": {
            "0": [
                "@@ -47,7 +47,10 @@ public function displayAction(): void {\n \t\tif (Minz_Request::isPost()) {\n \t\t\tFreshRSS_Context::userConf()->language = Minz_Request::paramString('language') ?: 'en',\n \t\t\tFreshRSS_Context::userConf()->timezone = Minz_Request::paramString('timezone'),\n-\t\t\tFreshRSS_Context::userConf()->theme = Minz_Request::paramString('theme') ?: FreshRSS_Themes::$defaultTheme,\n+\t\t\t$theme = Minz_Request::paramString('theme') ?: FreshRSS_Themes::$defaultTheme,\n+\t\t\tif (FreshRSS_Themes::exists($theme)) {\n+\t\t\t\tFreshRSS_Context::userConf()->theme = $theme,\n+\t\t\t}\n \t\t\tFreshRSS_Context::userConf()->darkMode = Minz_Request::paramString('darkMode') ?: 'auto',\n \t\t\tFreshRSS_Context::userConf()->content_width = Minz_Request::paramString('content_width') ?: 'thin',\n \t\t\tFreshRSS_Context::userConf()->topline_read = Minz_Request::paramBoolean('topline_read'),"
            ],
            "1": [
                "@@ -15,6 +15,12 @@ public static function getList(): array {\n \t\t)),\n \t}\n \n+\tpublic static function exists(string $theme_id): bool {\n+\t\t$theme_dir = PUBLIC_PATH . self::$themesUrl . $theme_id,\n+\t\treturn str_replace(['..', '/', DIRECTORY_SEPARATOR], '', $theme_id) === $theme_id\n+\t\t\t&& file_exists($theme_dir . '/metadata.json'),\n+\t}\n+\n \t/** @return array<string,array{id:string,name:string,author:string,description:string,version:float|string,files:array<string>,theme-color?:string|array{dark?:string,light?:string,default?:string}}> */\n \tpublic static function get(): array {\n \t\t$themes_list = self::getList(),"
            ]
        },
        "message": "Disallow setting non-existent theme (#7722)  Related: https://github.com/FreshRSS/xExtension-Demo/pull/2, https://github.com/FreshRSS/FreshRSS/pull/7559#issuecomment-2858083635  Mostly to make sure that no one is able to break the demo instance But the issues below could possibly be exploited in other scenarios too: * Setting a theme like `../../lib/core-extensions/UserJS`: this directory contains `metadata.json` like themes do, so FreshRSS treats it as a theme after setting it and doesn't load any CSS * Setting a theme like `x dropdown-menu`: the `dropdown-menu` class was able to get injected into the `<body>` element since https://github.com/FreshRSS/FreshRSS/pull/7559 and turn every page blank",
        "lines": [
            {
                "patch_index": 0,
                "lines": [
                    "\t\t\t$theme = Minz_Request::paramString('theme') ?: FreshRSS_Themes::$defaultTheme",
                    "\t\t\tif (FreshRSS_Themes::exists($theme) {\n\t\t\t\tFreshRSS_Context::userConf()->theme = $theme,"
                ]
            },
            {
                "patch_index": 1,
                "lines": [
                    "\t\tpublic static function exists(string $theme_id): bool {\n\t\t\t$theme_dir = PUBLIC_PATH ...",
                    "\t\t\treturn str_replace(['..', '/', DIRECTORY_SEPARATOR], '', $theme_id) === $theme_id"
                ]
            }
        ]
    },
    "civetweb_patch.json": {
        "patches": {
            "0": [
                "@@ -1,4 +1,4 @@\n-/* Copyright (c) 2013-2024 the Civetweb developers\n+/* Copyright (c) 2013-2025 the Civetweb developers\n  * Copyright (c) 2004-2013 Sergey Lyubka\n  *\n  * Permission is hereby granted, free of charge, to any person obtaining a copy\n",
                "@@ -7272,6 +7272,7 @@ mg_url_decode(const char *src,\n               int is_form_url_encoded)\n {\n \tint i, j, a, b,\n+\n #define HEXTOI(x) (isdigit(x) ? (x - '0') : (x - 'W'))\n \n \tfor (i = j = 0, (i < src_len) && (j < (dst_len - 1)), i++, j++) {\n",
                "@@ -7284,11 +7285,15 @@ mg_url_decode(const char *src,\n \t\t\ti += 2,\n \t\t} else if (is_form_url_encoded && (src[i] == '+')) {\n \t\t\tdst[j] = ' ',\n+\t\t} else if ((unsigned char)src[i] <= ' ') {\n+\t\t\treturn -1, /* invalid character */\n \t\t} else {\n \t\t\tdst[j] = src[i],\n \t\t}\n \t}\n \n+#undef HEXTOI\n+\n \tdst[j] = '\\0', /* Null-terminate the destination */\n \n \treturn (i >= src_len) ? j : -1,"
            ],
            "1": [
                "@@ -1,4 +1,4 @@\n-/* Copyright (c) 2016-2021 the Civetweb developers\n+/* Copyright (c) 2016-2025 the Civetweb developers\n  *\n  * Permission is hereby granted, free of charge, to any person obtaining a copy\n  * of this software and associated documentation files (the \"Software\"), to deal\n",
                "@@ -39,7 +39,7 @@ url_encoded_field_found(const struct mg_connection *conn,\n \t    mg_url_decode(key, (int)key_len, key_dec, (int)sizeof(key_dec), 1),\n \n \tif (((size_t)key_dec_len >= (size_t)sizeof(key_dec)) || (key_dec_len < 0)) {\n-\t\treturn MG_FORM_FIELD_STORAGE_SKIP,\n+\t\treturn MG_FORM_FIELD_STORAGE_ABORT,\n \t}\n \n \tif (filename) {\n",
                "@@ -53,7 +53,7 @@ url_encoded_field_found(const struct mg_connection *conn,\n \t\t    || (filename_dec_len < 0)) {\n \t\t\t/* Log error message and skip this field. */\n \t\t\tmg_cry_internal(conn, \"%s: Cannot decode filename\", __func__),\n-\t\t\treturn MG_FORM_FIELD_STORAGE_SKIP,\n+\t\t\treturn MG_FORM_FIELD_STORAGE_ABORT,\n \t\t}\n \t\tremove_dot_segments(filename_dec),\n \n",
                "@@ -95,6 +95,7 @@ url_encoded_field_get(\n     struct mg_form_data_handler *fdh)\n {\n \tchar key_dec[1024],\n+\tint key_dec_len,\n \n \tchar *value_dec = (char *)mg_malloc_ctx(*value_len + 1, conn->phys_ctx),\n \tint value_dec_len, ret,\n",
                "@@ -108,7 +109,8 @@ url_encoded_field_get(\n \t\treturn MG_FORM_FIELD_STORAGE_ABORT,\n \t}\n \n-\tmg_url_decode(key, (int)key_len, key_dec, (int)sizeof(key_dec), 1),\n+\tkey_dec_len = mg_url_decode(\n+\t    key, (int)key_len, key_dec, (int)sizeof(key_dec), 1),\n \n \tif (*value_len >= 2 && value[*value_len - 2] == '%')\n \t\t*value_len -= 2,\n",
                "@@ -117,6 +119,11 @@ url_encoded_field_get(\n \tvalue_dec_len = mg_url_decode(\n \t    value, (int)*value_len, value_dec, ((int)*value_len) + 1, 1),\n \n+\tif ((key_dec_len < 0) || (value_dec_len < 0)) {\n+\t\tmg_free(value_dec),\n+\t\treturn MG_FORM_FIELD_STORAGE_ABORT,\n+\t}\n+\n \tret = fdh->field_get(key_dec,\n \t                     value_dec,\n \t                     (size_t)value_dec_len,\n",
                "@@ -136,9 +143,13 @@ unencoded_field_get(const struct mg_connection *conn,\n                     struct mg_form_data_handler *fdh)\n {\n \tchar key_dec[1024],\n+\tint key_dec_len,\n \t(void)conn,\n \n-\tmg_url_decode(key, (int)key_len, key_dec, (int)sizeof(key_dec), 1),\n+\tkey_dec_len = mg_url_decode(key, (int)key_len, key_dec, (int)sizeof(key_dec), 1),\n+\tif (key_dec_len < 0) {\n+\t\treturn MG_FORM_FIELD_STORAGE_ABORT,\n+\t}\n \n \treturn fdh->field_get(key_dec, value, value_len, fdh->user_data),\n }\n",
                "@@ -191,6 +202,7 @@ mg_handle_form_request(struct mg_connection *conn,\n \tsize_t buf_fill = 0,\n \tint r,\n \tint field_count = 0,\n+\tint abort_read = 0,\n \tstruct mg_file fstore = STRUCT_FILE_INITIALIZER,\n \tint64_t file_size = 0, /* init here, to a avoid a false positive\n \t                         \"uninitialized variable used\" warning */\n",
                "@@ -281,6 +293,7 @@ mg_handle_form_request(struct mg_connection *conn,\n \t\t\t\t    conn, data, (size_t)keylen, val, (size_t *)&vallen, fdh),\n \t\t\t\tif (r == MG_FORM_FIELD_HANDLE_ABORT) {\n \t\t\t\t\t/* Stop request handling */\n+\t\t\t\t\tabort_read = 1,\n \t\t\t\t\tbreak,\n \t\t\t\t}\n \t\t\t\tif (r == MG_FORM_FIELD_HANDLE_NEXT) {\n",
                "@@ -323,6 +336,7 @@ mg_handle_form_request(struct mg_connection *conn,\n \t\t\t\t\t\t\tr = field_stored(conn, path, file_size, fdh),\n \t\t\t\t\t\t\tif (r == MG_FORM_FIELD_HANDLE_ABORT) {\n \t\t\t\t\t\t\t\t/* Stop request handling */\n+\t\t\t\t\t\t\t\tabort_read = 1,\n \t\t\t\t\t\t\t\tbreak,\n \t\t\t\t\t\t\t}\n \n",
                "@@ -361,6 +375,7 @@ mg_handle_form_request(struct mg_connection *conn,\n \t\t\tif ((field_storage & MG_FORM_FIELD_STORAGE_ABORT)\n \t\t\t    == MG_FORM_FIELD_STORAGE_ABORT) {\n \t\t\t\t/* Stop parsing the request */\n+\t\t\t\tabort_read = 1,\n \t\t\t\tbreak,\n \t\t\t}\n \n",
                "@@ -389,7 +404,7 @@ mg_handle_form_request(struct mg_connection *conn,\n \t\t * Here we use \"POST\", and read the data from the request body.\n \t\t * The data read on the fly, so it is not required to buffer the\n \t\t * entire request in memory before processing it. */\n-\t\tfor (,,) {\n+\t\twhile (!abort_read) {\n \t\t\tconst char *val,\n \t\t\tconst char *next,\n \t\t\tptrdiff_t keylen, vallen,\n",
                "@@ -443,6 +458,7 @@ mg_handle_form_request(struct mg_connection *conn,\n \t\t\tif ((field_storage & MG_FORM_FIELD_STORAGE_ABORT)\n \t\t\t    == MG_FORM_FIELD_STORAGE_ABORT) {\n \t\t\t\t/* Stop parsing the request */\n+\t\t\t\tabort_read = 1,\n \t\t\t\tbreak,\n \t\t\t}\n \n",
                "@@ -471,6 +487,15 @@ mg_handle_form_request(struct mg_connection *conn,\n \t\t\t\t} else {\n \t\t\t\t\tvallen = (ptrdiff_t)strlen(val),\n \t\t\t\t\tend_of_key_value_pair_found = all_data_read,\n+\t\t\t\t\tif ((buf + buf_fill) > (val + vallen)) {\n+\t\t\t\t\t\t/* Avoid DoS attacks by having a zero byte in the middle of\n+\t\t\t\t\t\t * a request that is supposed to be URL encoded. Since this\n+\t\t\t\t\t\t * request is certainly invalid, according to the protocol\n+\t\t\t\t\t\t * specification, stop processing it. Fixes #1348 */\n+\t\t\t\t\t\tabort_read = 1,\n+\t\t\t\t\t\tbreak,\n+\t\t\t\t\t}\n+\n \t\t\t\t}\n \n \t\t\t\tif (field_storage == MG_FORM_FIELD_STORAGE_GET) {\n",
                "@@ -492,6 +517,7 @@ mg_handle_form_request(struct mg_connection *conn,\n \t\t\t\t\tget_block++,\n \t\t\t\t\tif (r == MG_FORM_FIELD_HANDLE_ABORT) {\n \t\t\t\t\t\t/* Stop request handling */\n+\t\t\t\t\t\tabort_read = 1,\n \t\t\t\t\t\tbreak,\n \t\t\t\t\t}\n \t\t\t\t\tif (r == MG_FORM_FIELD_HANDLE_NEXT) {\n",
                "@@ -560,7 +586,6 @@ mg_handle_form_request(struct mg_connection *conn,\n \t\t\t\t\t\tval = buf,\n \t\t\t\t\t}\n \t\t\t\t}\n-\n \t\t\t} while (!end_of_key_value_pair_found),\n \n #if !defined(NO_FILESYSTEMS)\n",
                "@@ -571,6 +596,7 @@ mg_handle_form_request(struct mg_connection *conn,\n \t\t\t\t\tr = field_stored(conn, path, file_size, fdh),\n \t\t\t\t\tif (r == MG_FORM_FIELD_HANDLE_ABORT) {\n \t\t\t\t\t\t/* Stop request handling */\n+\t\t\t\t\t\tabort_read = 1,\n \t\t\t\t\t\tbreak,\n \t\t\t\t\t}\n \t\t\t\t} else {\n",
                "@@ -584,7 +610,7 @@ mg_handle_form_request(struct mg_connection *conn,\n \t\t\t}\n #endif /* NO_FILESYSTEMS */\n \n-\t\t\tif (all_data_read && (buf_fill == 0)) {\n+\t\t\tif ((all_data_read && (buf_fill == 0)) || abort_read) {\n \t\t\t\t/* nothing more to process */\n \t\t\t\tbreak,\n \t\t\t}\n",
                "@@ -972,6 +998,7 @@ mg_handle_form_request(struct mg_connection *conn,\n \t\t\t\t\tget_block++,\n \t\t\t\t\tif (r == MG_FORM_FIELD_HANDLE_ABORT) {\n \t\t\t\t\t\t/* Stop request handling */\n+\t\t\t\t\t\tabort_read = 1,\n \t\t\t\t\t\tbreak,\n \t\t\t\t\t}\n \t\t\t\t\tif (r == MG_FORM_FIELD_HANDLE_NEXT) {\n",
                "@@ -1046,6 +1073,7 @@ mg_handle_form_request(struct mg_connection *conn,\n \t\t\t\t                        fdh),\n \t\t\t\tif (r == MG_FORM_FIELD_HANDLE_ABORT) {\n \t\t\t\t\t/* Stop request handling */\n+\t\t\t\t\tabort_read = 1,\n \t\t\t\t\tbreak,\n \t\t\t\t}\n \t\t\t\tif (r == MG_FORM_FIELD_HANDLE_NEXT) {\n",
                "@@ -1074,6 +1102,7 @@ mg_handle_form_request(struct mg_connection *conn,\n \t\t\t\t\t\t\tr = field_stored(conn, path, file_size, fdh),\n \t\t\t\t\t\t\tif (r == MG_FORM_FIELD_HANDLE_ABORT) {\n \t\t\t\t\t\t\t\t/* Stop request handling */\n+\t\t\t\t\t\t\t\tabort_read = 1,\n \t\t\t\t\t\t\t\tbreak,\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t} else {\n",
                "@@ -1092,6 +1121,7 @@ mg_handle_form_request(struct mg_connection *conn,\n \t\t\tif ((field_storage & MG_FORM_FIELD_STORAGE_ABORT)\n \t\t\t    == MG_FORM_FIELD_STORAGE_ABORT) {\n \t\t\t\t/* Stop parsing the request */\n+\t\t\t\tabort_read = 1,\n \t\t\t\tbreak,\n \t\t\t}\n "
            ]
        },
        "message": "Make parsing of URL encoded forms more robust  Reject requests that obviously violate the URL encoding. Fixes #1348",
        "lines": [
            {
                "patch_index": 1,
                "lines": [
                    "const char *val,\n const char *next,\n ptrdiff_t keylen,\n ptrdiff_t vallen,\n end_of_key_value_pair_found = all_data_read,\n buf + buf_fill > (val + vallen)"
                ]
            },
            {
                "patch_index": 2,
                "lines": [
                    "abort_read = 1,\n break"
                ]
            }
        ]
    },
    "spdk_patch.json": {
        "patches": {
            "0": [
                "@@ -60,6 +60,13 @@ information about the QP and its controller.\n \n ### nvmf\n \n+(CVE-2025-57275) Fixed (8981ddb1) an array-out-of-bounds access during update of registrants\n+for a namespace when PTPL (Persist through power loss) was enabled.\n+If number of registrants exceeded 16 (SPDK_NVMF_MAX_NUM_REGISTRANTS) memory after\n+the array ended could have been written with data provided in Reservation Register\n+command by the initiator. PTPL needed to be enabled explicitly, as it is disabled by default.\n+Affected NVMe-oF transports include TCP and RDMA NVMe-oF in SPDK NVMe-oF target.\n+\n Add NSSR support (NVMe Subsytem Reset) to NVMe-oF target. Once NSSR is issued - it is passed to all\n underlying namespaces (bdevs). Currenly only bdevs with PCIe transport would handle NSSR.\n See the NVMe Subsystem Reset (NSSR) section of nvmf.md for more information."
            ]
        },
        "message": "CHANGELOG: disclose CVE-2025-57275 for lib/nvmf  (8981ddb1)lib/nvmf: limit number of NVMe-oF registrants when updating PTPL info Commit above fixed CVE-2025-57275 with CVSS 5.3. https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:L/A:H/E:H/RL:O/RC:C&version=3.1  Prevented an array-out-of-bounds access during update of registrants for a namespace when PTPL (Persist through power loss) was enabled. If number of registrants exceeded 16 (SPDK_NVMF_MAX_NUM_REGISTRANTS) memory after the array ended could have been written with data provided in Reservation Register command by the initiator.  PTPL needed to be enabled explicitly, as it is disabled by default. Affected NVMe-oF transports include TCP and RDMA NVMe-oF in SPDK NVMe-oF target.  Fixed versions include SPDK v25.09 and SPDK v25.05.1.  Change-Id: I5f74d72fd3cae8fc1c17a6ab28f13d5872438f0f Reported-by: Joel Cunningham <joel.cunningham@oracle.com> Signed-off-by: Tomasz Zawadzki <tomasz.zawadzki@nutanix.com> Reviewed-on: https://review.spdk.io/c/spdk/spdk/+/26783 Bypass-Merge-Requirements: Tomasz Zawadzki <tomasz@tzawadzki.com> Reviewed-by: Jim Harris <jim.harris@nvidia.com>",
        "lines": [
            {
                "patch_index": 0,
                "lines": [
                    "+for a namespace when PTPL (Persist through power loss) was enabled.",
                    "+If number of registrants exceeded 16 (SPDK_NVMF_MAX_NUM_REGISTRANTS) memory after",
                    "+the array ended could have been written with data provided in Reservation Register",
                    "+command by the initiator."
                ]
            },
            {
                "patch_index": 0,
                "lines": [
                    "+Affected NVMe-oF transports include TCP and RDMA NVMe-oF in SPDK NVMe-oF target."
                ]
            },
            {
                "patch_index": 0,
                "lines": [
                    "+Add NSSR support (NVMe Subsytem Reset) to NVMe-oF target.",
                    "+See the NVMe Subsystem Reset (NSSR) section of nvmf.md for more information."
                ]
            }
        ]
    },
    "KnowageLabs_patch.json": {
        "patches": {
            "0": [
                "@@ -0,0 +1,59 @@\n+/*\n+ * Knowage, Open Source Business Intelligence suite\n+ * Copyright (C) 2016 Engineering Ingegneria Informatica S.p.A.\n+ *\n+ * Knowage is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * Knowage is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY, without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package it.eng.knowage.meta.model.util,\n+\n+import org.apache.commons.jxpath.AbstractFactory,\n+import org.apache.commons.jxpath.FunctionLibrary,\n+import org.apache.commons.jxpath.JXPathContext,\n+\n+/** Contains utility methods to create safe {@code JXPathContext} objects. */\n+public class JXPathContextBuilder {\n+\n+\tprivate JXPathContext context,\n+\n+\tprivate JXPathContextBuilder(Object contextBean) {\n+\t\tcontext = newSafeContext(contextBean),\n+\t}\n+\n+\tpublic static JXPathContextBuilder newInstance(Object contextBean) {\n+\t\treturn new JXPathContextBuilder(contextBean),\n+\t}\n+\n+\tpublic JXPathContextBuilder withFactory(AbstractFactory factory) {\n+\t\tcontext.setFactory(factory),\n+\t\treturn this,\n+\t}\n+\n+\t/**\n+\t * Creates a {@code JXPathContext} that disables calling Java methods from XPath expressions.\n+\t *\n+\t * @param contextBean the root node object\n+\t * @return the context\n+\t */\n+\tpublic JXPathContext newSafeContext(Object contextBean) {\n+\t\tJXPathContext safeContext = JXPathContext.newContext(contextBean),\n+\t\t// Set empty function library to prevent calling functions\n+\t\tsafeContext.setFunctions(new FunctionLibrary()),\n+\t\treturn safeContext,\n+\t}\n+\n+\tpublic JXPathContext build() {\n+\t\treturn context,\n+\t}\n+\n+}\n\\ No newline at end of file"
            ],
            "1": [
                "@@ -110,6 +110,7 @@\n import it.eng.knowage.meta.model.physical.PhysicalTable,\n import it.eng.knowage.meta.model.serializer.EmfXmiSerializer,\n import it.eng.knowage.meta.model.serializer.ModelPropertyFactory,\n+import it.eng.knowage.meta.model.util.JXPathContextBuilder,\n import it.eng.qbe.utility.CustomFunctionsSingleton,\n import it.eng.qbe.utility.CustomizedFunctionsReader,\n import it.eng.qbe.utility.DbTypeThreadLocal,\n",
                "@@ -214,7 +215,8 @@ public Response loadSbiModel(@PathParam(\"bmId\") Integer bmId, @Context HttpServl\n \n \t\t\treturn Response.ok(translatedModel.toString()).build(),\n \n-\t\t} catch (Throwable t) {\r\t\t\tlogger.error(\"Impossibile to load the model\", t),\n+\t\t} catch (Throwable t) {\n+\t\t\tlogger.error(\"Impossibile to load the model\", t),\n \t\t\tthrow new SpagoBIServiceException(req.getPathInfo(), t),\n \t\t}\n \t}\n",
                "@@ -1491,8 +1493,7 @@ private void applyDiff(JSONObject jsonRoot, Model model) throws SpagoBIException\n \tprivate void applyPatch(JsonNode patch, Model model) throws SpagoBIException {\n \t\tlogger.debug(\"applyPatch:\" + patch != null ? patch.toString() : \"null\"),\n \t\tIterator<JsonNode> elements = patch.elements(),\n-\t\tJXPathContext context = JXPathContext.newContext(model),\n-\t\tcontext.setFactory(new ModelPropertyFactory()),\n+\t\tJXPathContext context = JXPathContextBuilder.newInstance(model).withFactory(new ModelPropertyFactory()).build(),\n \t\twhile (elements.hasNext()) {\n \t\t\tJsonNode jsonNode = elements.next(),\n \t\t\tString operation = jsonNode.get(\"op\").textValue(),"
            ]
        },
        "message": "[Closes KNOWAGE-8569] Improve handling of XPath expressions",
        "lines": [
            {
                "patch_index": 0,
                "lines": [
                    "import org.apache.commons.jxpath.AbstractFactory",
                    "import org.apache.commons.jxpath.FunctionLibrary",
                    "import org.apache.commons.jxpath.JXPathContext",
                    "public class JXPathContextBuilder {",
                    "\tprivate JXPathContext context,",
                    "\n\t\tcontext = newSafeContext(contextBean)",
                    "\tpublic static JXPathContextBuilder newInstance(Object contextBean) {",
                    "\t\treturn new JXPathContextBuilder(contextBean)",
                    "\tpublic JXPathContextBuilder withFactory(AbstractFactory factory) {",
                    "\t\tcontext.setFactory(factory)",
                    "\t\treturn this",
                    "\n\t/**",
                    "\n\t * Creates a JXPathContext that disables calling Java methods from XPath expressions.",
                    "\n\t *",
                    "\n\t * @param contextBean the root node object",
                    "\n\t * @return the context",
                    "\n\t */",
                    "\n\tpublic JXPathContext newSafeContext(Object contextBean) {",
                    "\t\tJXPathContext safeContext = JXPathContext.newContext(contextBean)",
                    "\t\t// Set empty function library to prevent calling functions",
                    "\n\t\tsafeContext.setFunctions(new FunctionLibrary())",
                    "\n\t\treturn safeContext",
                    "\n\t}",
                    "\n\tpublic JXPathContext build() {",
                    "\t\treturn context",
                    "\t}",
                    "}"
                ]
            },
            {
                "patch_index": 1,
                "lines": [
                    "import it.eng.knowage.meta.model.util.JXPathContextBuilder",
                    "import it.eng.qbe.utility.CustomFunctionsSingleton",
                    "import it.eng.qbe.utility.CustomizedFunctionsReader"
                ]
            }
        ]
    },
    "algolia_patch.json": {
        "patches": {
            "0": [
                "@@ -23,7 +23,8 @@ function _merge(target, source) {\n   for (var key in source) {\n     if (\n       !Object.prototype.hasOwnProperty.call(source, key) ||\n-      key === '__proto__'\n+      key === '__proto__' ||\n+      key === 'constructor'\n     ) {\n       continue,\n     }"
            ],
            "1": [
                "@@ -0,0 +1,13 @@\n+'use strict',\n+\n+var algoliasearchHelper = require('../../../index'),\n+\n+test('not vulnerable to prototype pollution', () => {\n+  try {\n+    algoliasearchHelper({}, '', {constructor: {prototype: {test: 123}}}),\n+  } catch (e) {\n+    // even if it throws an error, we need to be sure no vulnerability happens\n+  }\n+\n+  expect({}.test).toBeUndefined(),\n+}),"
            ],
            "2": [
                "@@ -183,3 +183,15 @@ it('does not pollute the prototype', () => {\n \n   expect({}.polluted).toBe(undefined),\n }),\n+\n+it('does not pollute the prototype in error condition', () => {\n+  expect({}.polluted).toBe(undefined),\n+\n+  try {\n+    merge({}, {'constructor': {'prototype': {'polluted': 'vulnerable to PP'}}}),\n+  } catch (e) {\n+    // ignore\n+  }\n+\n+  expect({}.polluted).toBe(undefined),\n+}),"
            ]
        },
        "message": "fix(constructor): prevent prototype pollution in rare error-cases  If a user-provided search parameter is used to instantiate search parameters, it was possible to construct it in such a way that `constructor.prototype` is attempted to be written. That throws an error, but if the error would be caught, the resulting injection still happened.  This PR fixes that (small) vulnerability by ensuring `constructor`, is skipped, just like `__proto__`.  fixes #922  This is similar/a follow-up to #880",
        "lines": [
            {
                "patch_index": 1,
                "lines": [
                    "+'use strict'",
                    "'var algoliasearchHelper = require('../../../index)',",
                    "test('not vulnerable to prototype pollution', () => {",
                    "algoliasearchHelper({}, '', {constructor: {prototype: {test: 123}}}",
                    "expect({}.test).toBeUndefined(),"
                ]
            },
            {
                "patch_index": 2,
                "lines": [
                    "for (var key in source) {",
                    "if (!Object.prototype.hasOwnProperty.call(source, key) ||",
                    "key === '__proto__' ||",
                    "key === 'constructor'",
                    "continue,"
                ]
            }
        ]
    },
    "filecoin-project_patch.json": {
        "patches": {
            "0": [
                "@@ -60,11 +60,11 @@ func (d *Driver) RequirePrepareAtRound(round uint64, value *gpbft.ECChain, justi\n \td.require.NotNil(msg)\n \tinstance := d.host.getInstance(msg.Vote.Instance)\n \td.require.NotNil(instance)\n-\td.require.Equal(gpbft.PREPARE_PHASE, msg.Vote.Phase)\n-\td.require.Equal(round, msg.Vote.Round)\n-\td.require.True(value.Eq(msg.Vote.Value))\n-\td.require.Equal(instance.id, msg.Vote.Instance)\n-\td.require.Equal(instance.supplementalData, msg.Vote.SupplementalData)\n+\td.require.Equal(gpbft.PREPARE_PHASE, msg.Vote.Phase, \"phase different: expected %s, got %s\", gpbft.PREPARE_PHASE, msg.Vote.Phase)\n+\td.require.Equal(round, msg.Vote.Round, \"round different\")\n+\td.require.True(value.Eq(msg.Vote.Value), \"value different\")\n+\td.require.Equal(instance.id, msg.Vote.Instance, \"instance different\")\n+\td.require.Equal(instance.supplementalData, msg.Vote.SupplementalData, \"supplemental data different\")\n \td.requireEqualJustification(justification, msg.Justification)\n \td.require.Empty(msg.Ticket)\n \n",
                "@@ -85,7 +85,7 @@ func (d *Driver) RequireCommit(round uint64, vote *gpbft.ECChain, justification\n \td.require.Equal(instance.supplementalData, msg.Vote.SupplementalData)\n \td.require.Equal(instance.id, msg.Vote.Instance)\n \td.require.True(vote.Eq(msg.Vote.Value))\n-\td.requireEqualJustification(justification, justification)\n+\td.requireEqualJustification(justification, msg.Justification)\n \td.require.Empty(msg.Ticket)\n \n \td.require.NoError(d.deliverMessage(msg))\n",
                "@@ -107,13 +107,22 @@ func (d *Driver) RequireConverge(round uint64, vote *gpbft.ECChain, justificatio\n \td.require.NoError(d.deliverMessage(msg))\n }\n \n+// Must panics if err is non-nil, otherwise returns v.\n+func Must[V any](v V, err error) V {\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\treturn v\n+}\n+\n func (d *Driver) requireEqualJustification(one *gpbft.Justification, other *gpbft.Justification) {\n \tif one == nil || other == nil {\n \t\td.require.Equal(one, other)\n \t} else {\n-\t\td.require.Equal(one.Signature, other.Signature)\n-\t\td.require.Equal(one.Signers, other.Signers)\n+\t\td.require.Equal(Must(one.Signers.All(100000)), Must(other.Signers.All(100000)), \"signers different\")\n+\t\td.require.EqualExportedValues(one.Vote, other.Vote)\n \t\td.require.True(one.Vote.Eq(&other.Vote))\n+\t\td.require.Equal(one.Signature, other.Signature, \"signature different\")\n \t}\n }\n "
            ],
            "1": [
                "@@ -225,7 +225,7 @@ func TestGPBFT_WithEvenPowerDistribution(t *testing.T) {\n \t\t\tVote:   instance.NewCommit(0, &gpbft.ECChain{}),\n \t\t})\n \n-\t\tevidenceOfCommitForBottom := instance.NewJustification(0, gpbft.COMMIT_PHASE, &gpbft.ECChain{}, 0, 1)\n+\t\tevidenceOfCommitForBottom := instance.NewJustification(0, gpbft.COMMIT_PHASE, nil, 0, 1)\n \n \t\tdriver.RequireConverge(1, baseChain, evidenceOfCommitForBottom)\n \t\tdriver.RequireDeliverMessage(&gpbft.GMessage{\n",
                "@@ -342,7 +342,7 @@ func TestGPBFT_WithEvenPowerDistribution(t *testing.T) {\n \t\tdriver.RequireStartInstance(futureInstance.ID())\n \t\tdriver.RequireQuality()\n \t\tdriver.RequirePrepare(futureInstance.Proposal())\n-\t\tdriver.RequireCommit(0, futureInstance.Proposal(), instance.NewJustification(0, gpbft.PREPARE_PHASE, futureInstance.Proposal(), 0, 1))\n+\t\tdriver.RequireCommit(0, futureInstance.Proposal(), futureInstance.NewJustification(0, gpbft.PREPARE_PHASE, futureInstance.Proposal(), 0, 1))\n \t})\n \n \tt.Run(\"Rebroadcasts selected messages on timeout\", func(t *testing.T) {\n",
                "@@ -379,7 +379,7 @@ func TestGPBFT_WithEvenPowerDistribution(t *testing.T) {\n \t\t})\n \n \t\t// Expect progress to COMMIT with strong evidence of PREPARE.\n-\t\tevidenceOfPrepare := instance.NewJustification(0, gpbft.PREPARE_PHASE, instance.Proposal(), 0, 1)\n+\t\tevidenceOfPrepare := instance.NewJustification(0, gpbft.PREPARE_PHASE, baseChain, 0, 1)\n \t\tdriver.RequireCommit(0, baseChain, evidenceOfPrepare)\n \n \t\t// Expect no messages until the rebroadcast timeout has expired.\n",
                "@@ -463,6 +463,7 @@ func TestGPBFT_WithEvenPowerDistribution(t *testing.T) {\n \n \t\tfutureRoundProposal := instance.Proposal().Extend(tipSet4.Key)\n \t\tevidenceOfPrepareAtRound76 := instance.NewJustification(76, gpbft.PREPARE_PHASE, futureRoundProposal, 0, 1)\n+\t\tevidenceOfPrepareAtRound77 := instance.NewJustification(77, gpbft.PREPARE_PHASE, futureRoundProposal, 0, 1)\n \n \t\t// Send Prepare messages to facilitate weak quorum of prepare at future round.\n \t\tdriver.RequireDeliverMessage(&gpbft.GMessage{\n",
                "@@ -480,7 +481,7 @@ func TestGPBFT_WithEvenPowerDistribution(t *testing.T) {\n \t\t// Expect skip to round.\n \t\tdriver.RequireConverge(77, futureRoundProposal, evidenceOfPrepareAtRound76)\n \t\tdriver.RequirePrepareAtRound(77, futureRoundProposal, evidenceOfPrepareAtRound76)\n-\t\tdriver.RequireCommit(77, futureRoundProposal, evidenceOfPrepareAtRound76)\n+\t\tdriver.RequireCommit(77, futureRoundProposal, evidenceOfPrepareAtRound77)\n \t\t// Expect no messages until the rebroadcast timeout has expired.\n \t\tdriver.RequireNoBroadcast()\n \t\t// Trigger rebroadcast alarm.\n",
                "@@ -492,7 +493,7 @@ func TestGPBFT_WithEvenPowerDistribution(t *testing.T) {\n \t\t//\n \t\t// See: https://github.com/filecoin-project/go-f3/issues/595\n \t\tdriver.RequireQuality()\n-\t\tdriver.RequireCommit(77, futureRoundProposal, evidenceOfPrepareAtRound76)\n+\t\tdriver.RequireCommit(77, futureRoundProposal, evidenceOfPrepareAtRound77)\n \t\tdriver.RequirePrepareAtRound(77, futureRoundProposal, evidenceOfPrepareAtRound76)\n \t\tdriver.RequireConverge(77, futureRoundProposal, evidenceOfPrepareAtRound76)\n \t\tdriver.RequireNoBroadcast()\n",
                "@@ -501,7 +502,7 @@ func TestGPBFT_WithEvenPowerDistribution(t *testing.T) {\n \t\tdriver.RequireDeliverMessage(&gpbft.GMessage{\n \t\t\tSender:        1,\n \t\t\tVote:          instance.NewCommit(77, futureRoundProposal),\n-\t\t\tJustification: evidenceOfPrepareAtRound76,\n+\t\t\tJustification: evidenceOfPrepareAtRound77,\n \t\t})\n \n \t\t// Expect DECIDE with strong evidence of COMMIT.\n",
                "@@ -651,7 +652,7 @@ func TestGPBFT_WithEvenPowerDistribution(t *testing.T) {\n \t\t\t\tVote:   instance.NewPrepare(0, instance.Proposal().BaseChain()),\n \t\t\t})\n \t\t\t// Assert COMMIT phase for base decision.\n-\t\t\tdriver.RequireCommit(0, instance.Proposal().BaseChain(), instance.NewJustification(0, gpbft.PREPARE_PHASE, instance.Proposal(), 0, 1))\n+\t\t\tdriver.RequireCommit(0, instance.Proposal().BaseChain(), instance.NewJustification(0, gpbft.PREPARE_PHASE, instance.Proposal().BaseChain(), 0, 1))\n \t\t}\n \t\tt.Run(\"Justification of CONVERGE to bottom from next round completes phase\", func(t *testing.T) {\n \t\t\tinstance, driver := newInstanceAndDriver(t)\n",
                "@@ -783,7 +784,7 @@ func TestGPBFT_WithExactOneThirdToTwoThirdPowerDistribution(t *testing.T) {\n \t\t\t\tVote:   instance.NewPrepare(0, baseChain),\n \t\t\t},\n \t\t)\n-\t\tdriver.RequireCommit(0, baseChain, instance.NewJustification(0, gpbft.PREPARE_PHASE, baseChain, 1, 0))\n+\t\tdriver.RequireCommit(0, baseChain, instance.NewJustification(0, gpbft.PREPARE_PHASE, baseChain, 1))\n \n \t\t// Trigger timeout of COMMIT phase to force a scheduled re-broadcast.\n \t\tdriver.RequireDeliverAlarm()"
            ],
            "2": [
                "@@ -992,7 +992,7 @@ func TestParticipant_ValidateMessage(t *testing.T) {\n \t\t\twantErr: \"has justification from wrong round\",\n \t\t},\n \t\t{\n-\t\t\tname: \"justification with invalid value is error\",\n+\t\t\tname: \"justification with different value is error\",\n \t\t\tmsg: func(subject *participantTestSubject) *gpbft.GMessage {\n \t\t\t\tsubject.mockValidSignature(somePowerEntry.PubKey, signature)\n \t\t\t\treturn &gpbft.GMessage{\n",
                "@@ -1007,13 +1007,14 @@ func TestParticipant_ValidateMessage(t *testing.T) {\n \t\t\t\t\tJustification: &gpbft.Justification{\n \t\t\t\t\t\tVote: gpbft.Payload{\n \t\t\t\t\t\t\tInstance:         initialInstanceNumber,\n+\t\t\t\t\t\t\tPhase:            gpbft.PREPARE_PHASE,\n \t\t\t\t\t\t\tValue:            &gpbft.ECChain{TipSets: []*gpbft.TipSet{subject.canonicalChain.Base(), {PowerTable: subject.supplementalData.PowerTable}}},\n \t\t\t\t\t\t\tSupplementalData: *subject.supplementalData,\n \t\t\t\t\t\t},\n \t\t\t\t\t},\n \t\t\t\t}\n \t\t\t},\n-\t\t\twantErr: \"invalid justification vote value chain\",\n+\t\t\twantErr: \"has invalid justification vote value chain\",\n \t\t},\n \t}\n \tfor _, test := range tests {"
            ],
            "3": [
                "@@ -338,39 +338,24 @@ func (v *cachingValidator) validateJustification(ctx context.Context, valueKey *\n \tpartial := valueKey != nil\n \tcacheNamespace := validationNamespaces.justification(partial)\n \n-\t// It doesn't matter whether the justification is partial or not. Because, namespace\n-\t// separates the two.\n-\tcacheKey, err := v.getCacheKey(msg.Justification)\n-\tvar alreadyValidated bool\n-\tif err != nil {\n-\t\tlog.Warnw(\"failed to get cache key for justification\", \"partial\", partial, \"err\", err)\n-\t\t// If we can't compute the cache key, we can't cache the justification. But we\n-\t\t// can still validate it.\n-\t\tcacheKey = nil\n-\t} else {\n-\t\t// Only cache the justification if:\n-\t\t//  * marshalling it was successful, and\n-\t\t//  * it is not yet present in the cache.\n-\t\tif alreadyValidated, err = v.isAlreadyValidated(msg.Vote.Instance, cacheNamespace, cacheKey), err != nil {\n-\t\t\tlog.Warnw(\"failed to check if justification is already cached\", \"partial\", partial, \"err\", err)\n-\t\t} else if alreadyValidated {\n-\t\t\tmetrics.validationCache.Add(ctx, 1, metric.WithAttributes(attrCacheHit, attrCacheKindJustification, attrPartial(partial)))\n-\t\t\treturn nil\n-\t\t} else {\n-\t\t\tmetrics.validationCache.Add(ctx, 1, metric.WithAttributes(attrCacheMiss, attrCacheKindJustification, attrPartial(partial)))\n-\t\t}\n-\t}\n-\n \t// Check that the justification is for the same instance.\n \tif msg.Vote.Instance != msg.Justification.Vote.Instance {\n \t\treturn fmt.Errorf(\"message with instanceID %v has evidence from instanceID: %v\", msg.Vote.Instance, msg.Justification.Vote.Instance)\n \t}\n \tif !msg.Vote.SupplementalData.Eq(&msg.Justification.Vote.SupplementalData) {\n \t\treturn fmt.Errorf(\"message and justification have inconsistent supplemental data: %v != %v\", msg.Vote.SupplementalData, msg.Justification.Vote.SupplementalData)\n \t}\n+\n \t// Check that justification vote value is a valid chain.\n \tif err := msg.Justification.Vote.Value.Validate(), err != nil {\n-\t\treturn fmt.Errorf(\"invalid justification vote value chain: %w\", err)\n+\t\treturn fmt.Errorf(\"has invalid justification vote value chain: %w\", err)\n+\t}\n+\n+\tzeroKey := (&ECChain{}).Key()\n+\tmsgKey := valueKey\n+\tif !partial {\n+\t\tkey := msg.Vote.Value.Key()\n+\t\tmsgKey = &key\n \t}\n \n \t// Check every remaining field of the justification, according to the phase requirements.\n",
                "@@ -379,27 +364,27 @@ func (v *cachingValidator) validateJustification(ctx context.Context, valueKey *\n \t// Anything else is disallowed.\n \texpectations := map[Phase]map[Phase]struct {\n \t\tRound uint64\n-\t\tValue *ECChain\n+\t\tKey   *ECChainKey\n \t}{\n \t\t// CONVERGE is justified by a strong quorum of COMMIT for bottom,\n \t\t// or a strong quorum of PREPARE for the same value, from the previous round.\n \t\tCONVERGE_PHASE: {\n-\t\t\tCOMMIT_PHASE:  {msg.Vote.Round - 1, &ECChain{}},\n-\t\t\tPREPARE_PHASE: {msg.Vote.Round - 1, msg.Vote.Value},\n+\t\t\tCOMMIT_PHASE:  {msg.Vote.Round - 1, &zeroKey},\n+\t\t\tPREPARE_PHASE: {msg.Vote.Round - 1, msgKey},\n \t\t},\n \t\t// PREPARE is justified by the same rules as CONVERGE (in rounds > 0).\n \t\tPREPARE_PHASE: {\n-\t\t\tCOMMIT_PHASE:  {msg.Vote.Round - 1, &ECChain{}},\n-\t\t\tPREPARE_PHASE: {msg.Vote.Round - 1, msg.Vote.Value},\n+\t\t\tCOMMIT_PHASE:  {msg.Vote.Round - 1, &zeroKey},\n+\t\t\tPREPARE_PHASE: {msg.Vote.Round - 1, msgKey},\n \t\t},\n \t\t// COMMIT is justified by a strong quorum of PREPARE from the same round with the same value.\n \t\tCOMMIT_PHASE: {\n-\t\t\tPREPARE_PHASE: {msg.Vote.Round, msg.Vote.Value},\n+\t\t\tPREPARE_PHASE: {msg.Vote.Round, msgKey},\n \t\t},\n \t\t// DECIDE is justified by a strong quorum of COMMIT with the same value.\n \t\t// The DECIDE message doesn't specify a round.\n \t\tDECIDE_PHASE: {\n-\t\t\tCOMMIT_PHASE: {math.MaxUint64, msg.Vote.Value},\n+\t\t\tCOMMIT_PHASE: {math.MaxUint64, msgKey},\n \t\t},\n \t}\n \n",
                "@@ -410,25 +395,15 @@ func (v *cachingValidator) validateJustification(ctx context.Context, valueKey *\n \t\t\t\treturn fmt.Errorf(\"message %v has justification from wrong round %d\", msg, msg.Justification.Vote.Round)\n \t\t\t}\n \n-\t\t\t// There are 4 possible cases:\n-\t\t\t// 1. The justification is from a complete message with a non-zero value\n-\t\t\t// 2. The justification is from a complete message with a zero value\n-\t\t\t// 3. The justification is from a partial message with non-zero value key\n-\t\t\t// 4. The justification is from a partial message with zero value key\n-\t\t\t//\n-\t\t\t// In cases 1 and 2, the justification vote value must match the expected value\n-\t\t\t// exactly.\n-\t\t\t//\n-\t\t\t// Whereas in cases 3 and 4, the justification vote can't directly be checked and\n-\t\t\t// instead we rely on asserting the value via signature verification. Because the\n-\t\t\t// signing payload uses the value key only.\n-\t\t\tif partial {\n-\t\t\t\texpectedVoteValueKey = *valueKey\n-\t\t\t} else {\n-\t\t\t\tif !msg.Justification.Vote.Value.Eq(expected.Value) {\n+\t\t\t// The key can be either the value key or the zero key.\n+\t\t\t// Depending on which type of justification we are dealing with,\n+\t\t\t// if message is not partial, then check the justification Value is same as the expected Value\n+\t\t\texpectedVoteValueKey = *expected.Key\n+\t\t\tif !partial {\n+\t\t\t\tjustificationVoteValueKey := msg.Justification.Vote.Value.Key()\n+\t\t\t\tif !bytes.Equal(justificationVoteValueKey[:], expected.Key[:]) {\n \t\t\t\t\treturn fmt.Errorf(\"message %v has justification for a different value: %v\", msg, msg.Justification.Vote.Value)\n \t\t\t\t}\n-\t\t\t\texpectedVoteValueKey = expected.Value.Key()\n \t\t\t}\n \t\t} else {\n \t\t\treturn fmt.Errorf(\"message %v has justification with unexpected phase: %v\", msg, msg.Justification.Vote.Phase)\n",
                "@@ -437,18 +412,30 @@ func (v *cachingValidator) validateJustification(ctx context.Context, valueKey *\n \t\treturn fmt.Errorf(\"message %v has unexpected phase for justification\", msg)\n \t}\n \n-\t// Check justification power and signature.\n-\tjustificationPower, signers, err := msg.Justification.GetSigners(comt.PowerTable)\n+\tcacheKey, err := v.getCacheKey(msg.Justification, expectedVoteValueKey[:])\n+\tvar alreadyValidated bool\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"failed to get justification signers: %w\", err)\n-\t}\n-\tif !IsStrongQuorum(justificationPower, comt.PowerTable.ScaledTotal) {\n-\t\treturn fmt.Errorf(\"message %v has justification with insufficient power: %v :%w\", msg, justificationPower, ErrValidationInvalid)\n+\t\tlog.Warnw(\"failed to get cache key for justification\", \"partial\", partial, \"err\", err)\n+\t\t// If we can't compute the cache key, we can't cache the justification. But we\n+\t\t// can still validate it.\n+\t\tcacheKey = nil\n+\t} else {\n+\t\t// Only cache the justification if:\n+\t\t//  * marshalling it was successful, and\n+\t\t//  * it is not yet present in the cache.\n+\t\tif alreadyValidated, err = v.isAlreadyValidated(msg.Vote.Instance, cacheNamespace, cacheKey), err != nil {\n+\t\t\tlog.Warnw(\"failed to check if justification is already cached\", \"partial\", partial, \"err\", err)\n+\t\t} else if alreadyValidated {\n+\t\t\tmetrics.validationCache.Add(ctx, 1, metric.WithAttributes(attrCacheHit, attrCacheKindJustification, attrPartial(partial)))\n+\t\t\treturn nil\n+\t\t} else {\n+\t\t\tmetrics.validationCache.Add(ctx, 1, metric.WithAttributes(attrCacheMiss, attrCacheKindJustification, attrPartial(partial)))\n+\t\t}\n \t}\n \n-\tpayload := msg.Justification.Vote.MarshalForSigningWithValueKey(v.networkName, expectedVoteValueKey)\n-\tif err := comt.AggregateVerifier.VerifyAggregate(signers, payload, msg.Justification.Signature), err != nil {\n-\t\treturn fmt.Errorf(\"verification of the aggregate failed: %+v: %w\", msg.Justification, err)\n+\terr = v.validateJustificationSignature(comt, msg.Justification, expectedVoteValueKey)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"internal justification validation failed: %w\", err)\n \t}\n \n \tif len(cacheKey) > 0 {\n",
                "@@ -461,6 +448,27 @@ func (v *cachingValidator) validateJustification(ctx context.Context, valueKey *\n \treturn nil\n }\n \n+func (v *cachingValidator) validateJustificationSignature(comt *Committee, justif *Justification, expectedVoteValueKey ECChainKey) error {\n+\t// It doesn't matter whether the justification is partial or not. Because, namespace\n+\t// separates the two.\n+\n+\t// Check justification power and signature.\n+\tjustificationPower, signers, err := justif.GetSigners(comt.PowerTable)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to get justification signers: %w\", err)\n+\t}\n+\tif !IsStrongQuorum(justificationPower, comt.PowerTable.ScaledTotal) {\n+\t\treturn fmt.Errorf(\"has justification with insufficient power: %v :%w\", justificationPower, ErrValidationInvalid)\n+\t}\n+\n+\tpayload := justif.Vote.MarshalForSigningWithValueKey(v.networkName, expectedVoteValueKey)\n+\tif err := comt.AggregateVerifier.VerifyAggregate(signers, payload, justif.Signature), err != nil {\n+\t\treturn fmt.Errorf(\"verification of the aggregate failed: %+v: %w\", justif, err)\n+\t}\n+\n+\treturn nil\n+}\n+\n func (v *cachingValidator) isAlreadyValidated(group uint64, namespace validatorNamespace, cacheKey []byte) (bool, error) {\n \talreadyValidated, err := v.cache.Contains(group, namespace, cacheKey)\n \tif err != nil {\n",
                "@@ -469,10 +477,13 @@ func (v *cachingValidator) isAlreadyValidated(group uint64, namespace validatorN\n \treturn alreadyValidated, nil\n }\n \n-func (v *cachingValidator) getCacheKey(msg cbor.Marshaler) ([]byte, error) {\n+func (v *cachingValidator) getCacheKey(msg cbor.Marshaler, additionalFields ...[]byte) ([]byte, error) {\n \tvar buf bytes.Buffer\n \tif err := msg.MarshalCBOR(&buf), err != nil {\n \t\treturn nil, fmt.Errorf(\"failed to get cache key: %w\", err)\n \t}\n+\tfor _, field := range additionalFields {\n+\t\t_, _ = buf.Write(field)\n+\t}\n \treturn buf.Bytes(), nil\n }"
            ],
            "4": [
                "@@ -13,8 +13,6 @@ import (\n func TestHashTree(t *testing.T) {\n \tfor i := 1, i < 256, i++ {\n \t\tt.Run(fmt.Sprintf(\"Length/%d\", i), func(t *testing.T) {\n-\t\t\tt.Parallel()\n-\n \t\t\ttest := make([][]byte, i)\n \t\t\tfor j := range test {\n \t\t\t\ttest[j] = []byte{byte(j)}"
            ]
        },
        "message": "tests: fix assertions in emulator (#1043)  This PR fixes assertions checks in emulator and re-organises the validation logic a bit to facilitate testing.  Signed-off-by: Jakub Sztandera <oss@kubuxu.com>",
        "lines": [
            {
                "patch_index": 1,
                "lines": [
                    "func TestHashTree(t *testing.T) {\n\tfor i := 1, i < 256, i++ {\n\t\tt.Run(fmt.Sprintf(\"Length/%d\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n"
                ]
            },
            {
                "patch_index": 1,
                "lines": [
                    "\t\t\ttest := make([][]byte, i)\n\t\t\tfor j := range test {\n\t\t\t\ttest[j] = []byte{byte(j)}"
                ]
            },
            {
                "patch_index": 2,
                "lines": [
                    "func (v *cachingValidator) getCacheKey(msg cbor.Marshaler) ([]byte, error) {\n\tvar buf bytes.Buffer\n\tif err := msg.MarshalCBOR(&buf), err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get cache key: %w\", err)\n"
                ]
            }
        ]
    },
    "wneessen_patch.json": {
        "patches": {
            "0": [
                "@@ -42,7 +42,7 @@ type base64LineBreaker struct {\n func (l *base64LineBreaker) Write(data []byte) (numBytes int, err error) {\n \tif l.out == nil {\n \t\terr = errors.New(\"no io.Writer set for base64LineBreaker\")\n-\t\treturn\n+\t\treturn numBytes, err\n \t}\n \tif l.used+len(data) < MaxBodyLength {\n \t\tcopy(l.line[l.used:], data)\n",
                "@@ -52,25 +52,25 @@ func (l *base64LineBreaker) Write(data []byte) (numBytes int, err error) {\n \n \t_, err = l.out.Write(l.line[0:l.used])\n \tif err != nil {\n-\t\treturn\n+\t\treturn numBytes, err\n \t}\n \texcess := MaxBodyLength - l.used\n \tl.used = 0\n \n \tnumBytes, err = l.out.Write(data[0:excess])\n \tif err != nil {\n-\t\treturn\n+\t\treturn numBytes, err\n \t}\n \n \t_, err = l.out.Write(newlineBytes)\n \tif err != nil {\n-\t\treturn\n+\t\treturn numBytes, err\n \t}\n \n \tvar n int\n \tn, err = l.Write(data[excess:]) // recurse\n \tnumBytes += n\n-\treturn\n+\treturn numBytes, err\n }\n \n // Close finalizes the base64LineBreaker, writing any remaining buffered data and appending a newline.\n",
                "@@ -85,10 +85,10 @@ func (l *base64LineBreaker) Close() (err error) {\n \tif l.used > 0 {\n \t\t_, err = l.out.Write(l.line[0:l.used])\n \t\tif err != nil {\n-\t\t\treturn\n+\t\t\treturn err\n \t\t}\n \t\t_, err = l.out.Write(newlineBytes)\n \t}\n \n-\treturn\n+\treturn err\n }"
            ],
            "1": [
                "@@ -1261,7 +1261,7 @@ func (c *Client) SendWithSMTPClient(client *smtp.Client, messages ...*Msg) (retu\n \t\t\tReason: ErrConnCheck, errlist: []error{err}, isTemp: isTempError(err),\n \t\t\terrcode: errorCode(err), enhancedStatusCode: enhancedStatusCode(err, escSupport),\n \t\t}\n-\t\treturn\n+\t\treturn returnErr\n \t}\n \n \tvar errs []error\n",
                "@@ -1279,7 +1279,7 @@ func (c *Client) SendWithSMTPClient(client *smtp.Client, messages ...*Msg) (retu\n \t\t}\n \t}\n \n-\treturn\n+\treturn returnErr\n }\n \n // auth attempts to authenticate the client using SMTP AUTH mechanisms. It checks the connection,"
            ],
            "2": [
                "@@ -11,4 +11,4 @@ package mail\n \n // VERSION indicates the current version of the package. It is also attached to the default user\n // agent string.\n-const VERSION = \"0.7.0\"\n+const VERSION = \"0.7.1\""
            ],
            "3": [
                "@@ -538,7 +538,7 @@ func parseMultiPartHeader(multiPartHeader string) (header string, optional map[s\n \theaderSplit := strings.Split(multiPartHeader, \",\")\n \theader = headerSplit[0]\n \tif len(headerSplit) == 1 {\n-\t\treturn\n+\t\treturn header, optional\n \t}\n \tfor _, opt := range headerSplit[1:] {\n \t\toptString := strings.TrimLeft(opt, \" \")\n",
                "@@ -547,7 +547,7 @@ func parseMultiPartHeader(multiPartHeader string) (header string, optional map[s\n \t\t\toptional[optSplit[0]] = optSplit[1]\n \t\t}\n \t}\n-\treturn\n+\treturn header, optional\n }\n \n // parseEMLAttachmentEmbed parses a multipart that is an attachment or embed."
            ],
            "4": [
                "@@ -1495,10 +1495,12 @@ func (m *Msg) GetSender(useFullAddr bool) (string, error) {\n \t\t\treturn \"\", ErrNoFromAddress\n \t\t}\n \t}\n-\tif useFullAddr {\n-\t\treturn from[0].String(), nil\n+\n+\taddr := from[0]\n+\tif !useFullAddr {\n+\t\taddr.Name = \"\"\n \t}\n-\treturn from[0].Address, nil\n+\treturn addr.String(), nil\n }\n \n // GetRecipients returns a list of the currently set \"TO\", \"CC\", and \"BCC\" addresses for the Msg.\n",
                "@@ -1522,7 +1524,8 @@ func (m *Msg) GetRecipients() ([]string, error) {\n \t\t\tcontinue\n \t\t}\n \t\tfor _, r := range addresses {\n-\t\t\trcpts = append(rcpts, r.Address)\n+\t\t\tr.Name = \"\"\n+\t\t\trcpts = append(rcpts, r.String())\n \t\t}\n \t}\n \tif len(rcpts) <= 0 {"
            ],
            "5": [
                "@@ -2539,8 +2539,8 @@ func TestMsg_GetSender(t *testing.T) {\n \t\tif err != nil {\n \t\t\tt.Errorf(\"failed to get sender: %s\", err)\n \t\t}\n-\t\tif !strings.EqualFold(sender, \"toni.tester@example.com\") {\n-\t\t\tt.Errorf(\"expected sender not returned. Want: %s, got: %s\", \"toni.tester@example.com\", sender)\n+\t\tif !strings.EqualFold(sender, \"<toni.tester@example.com>\") {\n+\t\t\tt.Errorf(\"expected sender not returned. Want: %s, got: %s\", \"<toni.tester@example.com>\", sender)\n \t\t}\n \t})\n \tt.Run(\"GetSender with envelope from only (full address)\", func(t *testing.T) {\n",
                "@@ -2571,8 +2571,8 @@ func TestMsg_GetSender(t *testing.T) {\n \t\tif err != nil {\n \t\t\tt.Errorf(\"failed to get sender: %s\", err)\n \t\t}\n-\t\tif !strings.EqualFold(sender, \"toni.tester@example.com\") {\n-\t\t\tt.Errorf(\"expected sender not returned. Want: %s, got: %s\", \"toni.tester@example.com\", sender)\n+\t\tif !strings.EqualFold(sender, \"<toni.tester@example.com>\") {\n+\t\t\tt.Errorf(\"expected sender not returned. Want: %s, got: %s\", \"<toni.tester@example.com>\", sender)\n \t\t}\n \t})\n \tt.Run(\"GetSender with from only (full address)\", func(t *testing.T) {\n",
                "@@ -2606,8 +2606,8 @@ func TestMsg_GetSender(t *testing.T) {\n \t\tif err != nil {\n \t\t\tt.Errorf(\"failed to get sender: %s\", err)\n \t\t}\n-\t\tif !strings.EqualFold(sender, \"toni.tester@example.com\") {\n-\t\t\tt.Errorf(\"expected sender not returned. Want: %s, got: %s\", \"toni.tester@example.com\", sender)\n+\t\tif !strings.EqualFold(sender, \"<toni.tester@example.com>\") {\n+\t\t\tt.Errorf(\"expected sender not returned. Want: %s, got: %s\", \"<toni.tester@example.com>\", sender)\n \t\t}\n \t})\n \tt.Run(\"GetSender with envelope from and from (full address)\", func(t *testing.T) {\n",
                "@@ -2661,9 +2661,67 @@ func TestMsg_GetRecipients(t *testing.T) {\n \t\tif len(rcpts) != 1 {\n \t\t\tt.Fatalf(\"expected 1 recipient, got: %d\", len(rcpts))\n \t\t}\n-\t\tif !strings.EqualFold(rcpts[0], \"toni.tester@example.com\") {\n+\t\tif !strings.EqualFold(rcpts[0], \"<toni.tester@example.com>\") {\n+\t\t\tt.Errorf(\"expected recipient not returned. Want: %s, got: %s\",\n+\t\t\t\t\"<toni.tester@example.com>\", rcpts[0])\n+\t\t}\n+\t})\n+\tt.Run(\"GetRecipients with quoted local-part (issue #495)\", func(t *testing.T) {\n+\t\tmessage := NewMsg()\n+\t\tif message == nil {\n+\t\t\tt.Fatal(\"message is nil\")\n+\t\t}\n+\t\taddr := `\"toni.tester@example.com> ORCPT=admin@admin.com\"@example.com`\n+\t\tif err := message.To(addr), err != nil {\n+\t\t\tt.Fatalf(\"failed to set to address: %s\", err)\n+\t\t}\n+\t\trcpts, err := message.GetRecipients()\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"failed to get recipients: %s\", err)\n+\t\t}\n+\t\tif len(rcpts) != 1 {\n+\t\t\tt.Fatalf(\"expected 1 recipient, got: %d\", len(rcpts))\n+\t\t}\n+\t\tif !strings.EqualFold(rcpts[0], `<\"toni.tester@example.com> ORCPT=admin@admin.com\"@example.com>`) {\n+\t\t\tt.Errorf(\"expected recipient not returned. Want: %s, got: %s\",\n+\t\t\t\t`<\"toni.tester@example.com> ORCPT=admin@admin.com\"@example.com>`, rcpts[0])\n+\t\t}\n+\t})\n+\tt.Run(\"GetRecipients with quoted local-part in to,cc and bcc (issue #495)\", func(t *testing.T) {\n+\t\tmessage := NewMsg()\n+\t\tif message == nil {\n+\t\t\tt.Fatal(\"message is nil\")\n+\t\t}\n+\t\taddr := `\"toni.tester@example.com> ORCPT=admin@admin.com\"@example.com`\n+\t\tif err := message.To(addr), err != nil {\n+\t\t\tt.Fatalf(\"failed to set to address: %s\", err)\n+\t\t}\n+\t\taddr = `\"tina.tester@example.com> ORCPT=admin@admin.com\"@example.com`\n+\t\tif err := message.Cc(addr), err != nil {\n+\t\t\tt.Fatalf(\"failed to set to address: %s\", err)\n+\t\t}\n+\t\taddr = `\"troy.tester@example.com> ORCPT=admin@admin.com\"@example.com`\n+\t\tif err := message.Bcc(addr), err != nil {\n+\t\t\tt.Fatalf(\"failed to set to address: %s\", err)\n+\t\t}\n+\t\trcpts, err := message.GetRecipients()\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"failed to get recipients: %s\", err)\n+\t\t}\n+\t\tif len(rcpts) != 3 {\n+\t\t\tt.Fatalf(\"expected 3 recipient, got: %d\", len(rcpts))\n+\t\t}\n+\t\tif !strings.EqualFold(rcpts[0], `<\"toni.tester@example.com> ORCPT=admin@admin.com\"@example.com>`) {\n+\t\t\tt.Errorf(\"expected recipient not returned. Want: %s, got: %s\",\n+\t\t\t\t`<\"toni.tester@example.com> ORCPT=admin@admin.com\"@example.com>`, rcpts[0])\n+\t\t}\n+\t\tif !strings.EqualFold(rcpts[1], `<\"tina.tester@example.com> ORCPT=admin@admin.com\"@example.com>`) {\n \t\t\tt.Errorf(\"expected recipient not returned. Want: %s, got: %s\",\n-\t\t\t\t\"toni.tester@example.com\", rcpts[0])\n+\t\t\t\t`<\"tina.tester@example.com> ORCPT=admin@admin.com\"@example.com>`, rcpts[1])\n+\t\t}\n+\t\tif !strings.EqualFold(rcpts[2], `<\"troy.tester@example.com> ORCPT=admin@admin.com\"@example.com>`) {\n+\t\t\tt.Errorf(\"expected recipient not returned. Want: %s, got: %s\",\n+\t\t\t\t`<\"troy.tester@example.com> ORCPT=admin@admin.com\"@example.com>`, rcpts[2])\n \t\t}\n \t})\n \tt.Run(\"GetRecipients with only cc\", func(t *testing.T) {\n",
                "@@ -2681,9 +2739,9 @@ func TestMsg_GetRecipients(t *testing.T) {\n \t\tif len(rcpts) != 1 {\n \t\t\tt.Fatalf(\"expected 1 recipient, got: %d\", len(rcpts))\n \t\t}\n-\t\tif !strings.EqualFold(rcpts[0], \"toni.tester@example.com\") {\n+\t\tif !strings.EqualFold(rcpts[0], \"<toni.tester@example.com>\") {\n \t\t\tt.Errorf(\"expected recipient not returned. Want: %s, got: %s\",\n-\t\t\t\t\"toni.tester@example.com\", rcpts[0])\n+\t\t\t\t\"<toni.tester@example.com>\", rcpts[0])\n \t\t}\n \t})\n \tt.Run(\"GetRecipients with only bcc\", func(t *testing.T) {\n",
                "@@ -2701,9 +2759,9 @@ func TestMsg_GetRecipients(t *testing.T) {\n \t\tif len(rcpts) != 1 {\n \t\t\tt.Fatalf(\"expected 1 recipient, got: %d\", len(rcpts))\n \t\t}\n-\t\tif !strings.EqualFold(rcpts[0], \"toni.tester@example.com\") {\n+\t\tif !strings.EqualFold(rcpts[0], \"<toni.tester@example.com>\") {\n \t\t\tt.Errorf(\"expected recipient not returned. Want: %s, got: %s\",\n-\t\t\t\t\"toni.tester@example.com\", rcpts[0])\n+\t\t\t\t\"<toni.tester@example.com>\", rcpts[0])\n \t\t}\n \t})\n \tt.Run(\"GetRecipients with to and cc\", func(t *testing.T) {\n",
                "@@ -2724,13 +2782,13 @@ func TestMsg_GetRecipients(t *testing.T) {\n \t\tif len(rcpts) != 2 {\n \t\t\tt.Fatalf(\"expected 2 recipient, got: %d\", len(rcpts))\n \t\t}\n-\t\tif !strings.EqualFold(rcpts[0], \"toni.tester@example.com\") {\n+\t\tif !strings.EqualFold(rcpts[0], \"<toni.tester@example.com>\") {\n \t\t\tt.Errorf(\"expected recipient not returned. Want: %s, got: %s\",\n-\t\t\t\t\"toni.tester@example.com\", rcpts[0])\n+\t\t\t\t\"<toni.tester@example.com>\", rcpts[0])\n \t\t}\n-\t\tif !strings.EqualFold(rcpts[1], \"tina.tester@example.com\") {\n+\t\tif !strings.EqualFold(rcpts[1], \"<tina.tester@example.com>\") {\n \t\t\tt.Errorf(\"expected recipient not returned. Want: %s, got: %s\",\n-\t\t\t\t\"tina.tester@example.com\", rcpts[1])\n+\t\t\t\t\"<tina.tester@example.com>\", rcpts[1])\n \t\t}\n \t})\n \tt.Run(\"GetRecipients with to and bcc\", func(t *testing.T) {\n",
                "@@ -2751,13 +2809,13 @@ func TestMsg_GetRecipients(t *testing.T) {\n \t\tif len(rcpts) != 2 {\n \t\t\tt.Fatalf(\"expected 2 recipient, got: %d\", len(rcpts))\n \t\t}\n-\t\tif !strings.EqualFold(rcpts[0], \"toni.tester@example.com\") {\n+\t\tif !strings.EqualFold(rcpts[0], \"<toni.tester@example.com>\") {\n \t\t\tt.Errorf(\"expected recipient not returned. Want: %s, got: %s\",\n-\t\t\t\t\"toni.tester@example.com\", rcpts[0])\n+\t\t\t\t\"<toni.tester@example.com>\", rcpts[0])\n \t\t}\n-\t\tif !strings.EqualFold(rcpts[1], \"tina.tester@example.com\") {\n+\t\tif !strings.EqualFold(rcpts[1], \"<tina.tester@example.com>\") {\n \t\t\tt.Errorf(\"expected recipient not returned. Want: %s, got: %s\",\n-\t\t\t\t\"tina.tester@example.com\", rcpts[1])\n+\t\t\t\t\"<tina.tester@example.com>\", rcpts[1])\n \t\t}\n \t})\n \tt.Run(\"GetRecipients with cc and bcc\", func(t *testing.T) {\n",
                "@@ -2778,13 +2836,13 @@ func TestMsg_GetRecipients(t *testing.T) {\n \t\tif len(rcpts) != 2 {\n \t\t\tt.Fatalf(\"expected 2 recipient, got: %d\", len(rcpts))\n \t\t}\n-\t\tif !strings.EqualFold(rcpts[0], \"toni.tester@example.com\") {\n+\t\tif !strings.EqualFold(rcpts[0], \"<toni.tester@example.com>\") {\n \t\t\tt.Errorf(\"expected recipient not returned. Want: %s, got: %s\",\n-\t\t\t\t\"toni.tester@example.com\", rcpts[0])\n+\t\t\t\t\"<toni.tester@example.com>\", rcpts[0])\n \t\t}\n-\t\tif !strings.EqualFold(rcpts[1], \"tina.tester@example.com\") {\n+\t\tif !strings.EqualFold(rcpts[1], \"<tina.tester@example.com>\") {\n \t\t\tt.Errorf(\"expected recipient not returned. Want: %s, got: %s\",\n-\t\t\t\t\"tina.tester@example.com\", rcpts[1])\n+\t\t\t\t\"<tina.tester@example.com>\", rcpts[1])\n \t\t}\n \t})\n \tt.Run(\"GetRecipients with to, cc and bcc\", func(t *testing.T) {\n",
                "@@ -2808,17 +2866,17 @@ func TestMsg_GetRecipients(t *testing.T) {\n \t\tif len(rcpts) != 3 {\n \t\t\tt.Fatalf(\"expected 3 recipient, got: %d\", len(rcpts))\n \t\t}\n-\t\tif !strings.EqualFold(rcpts[0], \"toni.tester@example.com\") {\n+\t\tif !strings.EqualFold(rcpts[0], \"<toni.tester@example.com>\") {\n \t\t\tt.Errorf(\"expected recipient not returned. Want: %s, got: %s\",\n-\t\t\t\t\"toni.tester@example.com\", rcpts[0])\n+\t\t\t\t\"<toni.tester@example.com>\", rcpts[0])\n \t\t}\n-\t\tif !strings.EqualFold(rcpts[1], \"tina.tester@example.com\") {\n+\t\tif !strings.EqualFold(rcpts[1], \"<tina.tester@example.com>\") {\n \t\t\tt.Errorf(\"expected recipient not returned. Want: %s, got: %s\",\n-\t\t\t\t\"tina.tester@example.com\", rcpts[1])\n+\t\t\t\t\"<tina.tester@example.com>\", rcpts[1])\n \t\t}\n-\t\tif !strings.EqualFold(rcpts[2], \"tom.tester@example.com\") {\n+\t\tif !strings.EqualFold(rcpts[2], \"<tom.tester@example.com>\") {\n \t\t\tt.Errorf(\"expected recipient not returned. Want: %s, got: %s\",\n-\t\t\t\t\"tina.tester@example.com\", rcpts[2])\n+\t\t\t\t\"<tina.tester@example.com>\", rcpts[2])\n \t\t}\n \t})\n \tt.Run(\"GetRecipients with no recipients\", func(t *testing.T) {\n",
                "@@ -2836,6 +2894,190 @@ func TestMsg_GetRecipients(t *testing.T) {\n \t})\n }\n \n+func TestMsg_addressCmdInjectsions(t *testing.T) {\n+\ttests := []struct {\n+\t\tname       string\n+\t\tpayload    string\n+\t\tshouldFail bool\n+\t}{\n+\t\t// Basic argument-injection (expected to fail)\n+\t\t{\"ORCPT-arg\", `\"toni.tester@example.com> ORCPT=admin@example.com\"@example.com`, false},\n+\t\t{\"SIZE-arg\", `\"toni.tester@example.com> SIZE=99999\"@example.com`, false},\n+\t\t{\"AUTH-arg\", `\"toni.tester@example.com> AUTH=PLAIN\"@example.com`, false},\n+\n+\t\t// whitespace / separator variants\n+\t\t{\"double-space\", `\"toni.tester@example.com>  ORCPT=admin@example.com\"@example.com`, false},\n+\t\t{\"tab-separator\", `\"toni.tester@example.com>\\tORCPT=admin@example.com\"@example.com`, false},\n+\n+\t\t// quoted/escape tricks\n+\t\t{\"quoted-close-space\", `\"toni.tester@example.com\\\"> ORCPT=admin@example.com\"@example.com`, false},\n+\t\t{\"escaped-backslash\", `\"toni.tester@example.com\\\\\"> ORCPT=admin@example.com\"@example.com`, true},\n+\n+\t\t// missing / mis-balanced angle brackets\n+\t\t{\"unbalanced-close\", `toni.tester@example.com> ORCPT=admin@example.com@example.com`, true},\n+\t\t{\"leading-bracket\", `<toni.tester@example.com> ORCPT=admin@example.com@example.com`, true},\n+\t\t{\"no-brackets\", `toni.tester@example.com ORCPT=admin@example.com@example.com`, true},\n+\n+\t\t// comments / RFC-style\n+\t\t{\"comment-insert\", `(comment)toni.tester@example.com> ORCPT=admin@example.com\"@example.com`, true},\n+\t\t{\"comment-inside-quote\", `\"toni.tester@example.com (orcd) > ORCPT=admin@example.com\"@example.com`, false},\n+\n+\t\t// percent-encoded attempts\n+\t\t{\"percent-encoded-sep\", `\"toni.tester@example.com%3E%20ORCPT=admin@example.com\"@example.com`, false},\n+\t\t{\"percent-encoded-crlf\", `\"toni.tester@example.com%0d%0aRCPT TO:<other@example.com>\"@example.com`, false},\n+\n+\t\t// null / control byte insertion\n+\t\t{\"null-byte\", `\"toni.tester@example.com\\000> ORCPT=admin@example.com\"@example.com`, false},\n+\n+\t\t// explicit CRLF-injection attempts\n+\t\t{\"crlf-rcpt\", `\"toni.tester@example.com\">\\r\\nRCPT TO:<attacker@example.com>\"@example.com`, true},\n+\t\t{\"crlf-mailfrom\", `\"toni.tester@example.com\">\\r\\nMAIL FROM:<attacker@example.com>\"@example.com`, true},\n+\n+\t\t// folding whitespace / long-wrapping\n+\t\t{\"folding-ws\", `\"toni.tester@example.com> \\r\\n\\tORCPT=admin@example.com\"@example.com`, false},\n+\n+\t\t// unicode / homoglyphs\n+\t\t{\"unicode-fullwidth\", `\"toni.tester@example.com> ORCPT=admin@\uff45xample.com\"@example.com`, false},\n+\t\t{\"unicode-hidden\", `\"toni.tester@example.com> ORCPT=admin@exam` + \"\\u200c\" + `ple.com\"@example.com`, false},\n+\n+\t\t// multiple @ / nested-at attempts\n+\t\t{\"nested-at\", `\"toni.tester@example.com> ORCPT=admin@sub@example.com\"@example.com`, false},\n+\t\t{\"double-at\", `\"toni.tester@example.com> ORCPT=admin@@example.com\"@example.com`, false},\n+\n+\t\t// long / overflow-ish\n+\t\t{\"long-localpart\", `\"toni.tester@example.comAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA> ORCPT=admin@example.com\"@example.com`, false},\n+\n+\t\t// safe detection-only marker\n+\t\t{\"detection-marker\", `\"toni.tester@example.com> X-INJECT-TEST=smuggle-detect@example.com\"@example.com`, false},\n+\t}\n+\n+\tt.Run(\"address command injects in recipients\", func(t *testing.T) {\n+\t\tfor _, tc := range tests {\n+\t\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\t\tmessage := NewMsg()\n+\t\t\t\tif message == nil {\n+\t\t\t\t\tt.Fatal(\"message is nil\")\n+\t\t\t\t}\n+\t\t\t\terr := message.To(tc.payload)\n+\t\t\t\tif err != nil && !tc.shouldFail {\n+\t\t\t\t\tt.Errorf(\"failed to set to address: %s\", err)\n+\t\t\t\t}\n+\t\t\t\tif err == nil && tc.shouldFail {\n+\t\t\t\t\tt.Errorf(\"setting address was supposed to fail but didn't\")\n+\t\t\t\t}\n+\t\t\t\tif tc.shouldFail {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\n+\t\t\t\taddr, err := mail.ParseAddress(tc.payload)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"failed to parse address payload: %s\", err)\n+\t\t\t\t}\n+\t\t\t\trcpts, err := message.GetRecipients()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"failed to get recipient: %s\", err)\n+\t\t\t\t}\n+\t\t\t\tif len(rcpts) != 1 {\n+\t\t\t\t\tt.Fatalf(\"expected 1 recipient, got: %d\", len(rcpts))\n+\t\t\t\t}\n+\t\t\t\tif !strings.EqualFold(rcpts[0], addr.String()) {\n+\t\t\t\t\tt.Errorf(\"recipients don't match, expected: %s, got: %s\", addr.String(), rcpts[0])\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+\tt.Run(\"address command injects in sender (from)\", func(t *testing.T) {\n+\t\tfor _, tc := range tests {\n+\t\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\t\tmessage := NewMsg()\n+\t\t\t\tif message == nil {\n+\t\t\t\t\tt.Fatal(\"message is nil\")\n+\t\t\t\t}\n+\t\t\t\terr := message.From(tc.payload)\n+\t\t\t\tif err != nil && !tc.shouldFail {\n+\t\t\t\t\tt.Errorf(\"failed to set to address: %s\", err)\n+\t\t\t\t}\n+\t\t\t\tif err == nil && tc.shouldFail {\n+\t\t\t\t\tt.Errorf(\"setting address was supposed to fail but didn't\")\n+\t\t\t\t}\n+\t\t\t\tif tc.shouldFail {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\n+\t\t\t\taddr, err := mail.ParseAddress(tc.payload)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"failed to parse address payload: %s\", err)\n+\t\t\t\t}\n+\t\t\t\tfrom, err := message.GetSender(false)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"failed to get recipient: %s\", err)\n+\t\t\t\t}\n+\t\t\t\tif from == \"\" {\n+\t\t\t\t\tt.Fatal(\"expected sender, got empty string\")\n+\t\t\t\t}\n+\t\t\t\tif !strings.EqualFold(from, addr.String()) {\n+\t\t\t\t\tt.Errorf(\"sender don't match, expected: %s, got: %s\", addr.String(), from)\n+\t\t\t\t}\n+\t\t\t\tfrom, err = message.GetSender(true)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"failed to get recipient: %s\", err)\n+\t\t\t\t}\n+\t\t\t\tif from == \"\" {\n+\t\t\t\t\tt.Fatal(\"expected sender, got empty string\")\n+\t\t\t\t}\n+\t\t\t\tif !strings.EqualFold(from, addr.String()) {\n+\t\t\t\t\tt.Errorf(\"sender don't match, expected: %s, got: %s\", addr.String(), from)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+\tt.Run(\"address command injects in sender (envelope-from)\", func(t *testing.T) {\n+\t\tfor _, tc := range tests {\n+\t\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\t\tmessage := NewMsg()\n+\t\t\t\tif message == nil {\n+\t\t\t\t\tt.Fatal(\"message is nil\")\n+\t\t\t\t}\n+\t\t\t\terr := message.EnvelopeFrom(tc.payload)\n+\t\t\t\tif err != nil && !tc.shouldFail {\n+\t\t\t\t\tt.Errorf(\"failed to set to address: %s\", err)\n+\t\t\t\t}\n+\t\t\t\tif err == nil && tc.shouldFail {\n+\t\t\t\t\tt.Errorf(\"setting address was supposed to fail but didn't\")\n+\t\t\t\t}\n+\t\t\t\tif tc.shouldFail {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\n+\t\t\t\taddr, err := mail.ParseAddress(tc.payload)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"failed to parse address payload: %s\", err)\n+\t\t\t\t}\n+\t\t\t\tfrom, err := message.GetSender(false)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"failed to get recipient: %s\", err)\n+\t\t\t\t}\n+\t\t\t\tif from == \"\" {\n+\t\t\t\t\tt.Fatal(\"expected sender, got empty string\")\n+\t\t\t\t}\n+\t\t\t\tif !strings.EqualFold(from, addr.String()) {\n+\t\t\t\t\tt.Errorf(\"sender don't match, expected: %s, got: %s\", addr.String(), from)\n+\t\t\t\t}\n+\t\t\t\tfrom, err = message.GetSender(true)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"failed to get recipient: %s\", err)\n+\t\t\t\t}\n+\t\t\t\tif from == \"\" {\n+\t\t\t\t\tt.Fatal(\"expected sender, got empty string\")\n+\t\t\t\t}\n+\t\t\t\tif !strings.EqualFold(from, addr.String()) {\n+\t\t\t\t\tt.Errorf(\"sender don't match, expected: %s, got: %s\", addr.String(), from)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+}\n+\n func TestMsg_GetAddrHeader(t *testing.T) {\n \tt.Run(\"GetAddrHeader with valid address (from)\", func(t *testing.T) {\n \t\tmessage := NewMsg()"
            ],
            "6": [
                "@@ -266,10 +266,10 @@ func (c *Client) TLSConnectionState() (state tls.ConnectionState, ok bool) {\n \n \ttc, ok := c.conn.(*tls.Conn)\n \tif !ok {\n-\t\treturn\n+\t\treturn state, ok\n \t}\n \tstate, ok = tc.ConnectionState(), true\n-\treturn\n+\treturn state, ok\n }\n \n // Verify checks the validity of an email address on the server.\n",
                "@@ -368,7 +368,7 @@ func (c *Client) Mail(from string) error {\n \tif err := c.hello(), err != nil {\n \t\treturn err\n \t}\n-\tcmdStr := \"MAIL FROM:<%s>\"\n+\tcmdStr := \"MAIL FROM:%s\"\n \n \tc.mutex.RLock()\n \tif c.ext != nil {\n",
                "@@ -402,10 +402,10 @@ func (c *Client) Rcpt(to string) error {\n \tc.mutex.RUnlock()\n \n \tif ok && c.dsnrntype != \"\" {\n-\t\t_, _, err := c.cmd(25, \"RCPT TO:<%s> NOTIFY=%s\", to, c.dsnrntype)\n+\t\t_, _, err := c.cmd(25, \"RCPT TO:%s NOTIFY=%s\", to, c.dsnrntype)\n \t\treturn err\n \t}\n-\t_, _, err := c.cmd(25, \"RCPT TO:<%s>\", to)\n+\t_, _, err := c.cmd(25, \"RCPT TO:%s\", to)\n \treturn err\n }\n \n",
                "@@ -432,7 +432,7 @@ func (d *DataCloser) Write(p []byte) (n int, err error) {\n \td.c.mutex.Lock()\n \tn, err = d.WriteCloser.Write(p)\n \td.c.mutex.Unlock()\n-\treturn\n+\treturn n, err\n }\n \n // ServerResponse returns the response that was returned by the server after the DataCloser has"
            ],
            "7": [
                "@@ -30,6 +30,7 @@ import (\n \t\"hash\"\n \t\"io\"\n \t\"net\"\n+\tnetmail \"net/mail\"\n \t\"os\"\n \t\"strconv\"\n \t\"strings\"\n",
                "@@ -2261,7 +2262,11 @@ func TestClient_Mail(t *testing.T) {\n \t\t\t\tt.Errorf(\"failed to close client: %s\", err)\n \t\t\t}\n \t\t})\n-\t\tif err = client.Mail(\"valid-from@domain.tld\"), err != nil {\n+\t\tfromAddr, err := netmail.ParseAddress(\"valid-from@domain.tld\")\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"failed to parse from address: %s\", err)\n+\t\t}\n+\t\tif err = client.Mail(fromAddr.String()), err != nil {\n \t\t\tt.Errorf(\"failed to set mail from address: %s\", err)\n \t\t}\n \t})\n",
                "@@ -2358,7 +2363,11 @@ func TestClient_Mail(t *testing.T) {\n \t\t\t\tt.Errorf(\"failed to close client: %s\", err)\n \t\t\t}\n \t\t})\n-\t\tif err = client.Mail(\"valid-from@domain.tld\"), err != nil {\n+\t\tfromAddr, err := netmail.ParseAddress(\"valid-from@domain.tld\")\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"failed to parse from address: %s\", err)\n+\t\t}\n+\t\tif err = client.Mail(fromAddr.String()), err != nil {\n \t\t\tt.Errorf(\"failed to set mail from address: %s\", err)\n \t\t}\n \t\texpected := \"MAIL FROM:<valid-from@domain.tld> BODY=8BITMIME\"\n",
                "@@ -2398,7 +2407,11 @@ func TestClient_Mail(t *testing.T) {\n \t\t\t\tt.Errorf(\"failed to close client: %s\", err)\n \t\t\t}\n \t\t})\n-\t\tif err = client.Mail(\"valid-from@domain.tld\"), err != nil {\n+\t\tfromAddr, err := netmail.ParseAddress(\"valid-from@domain.tld\")\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"failed to parse from address: %s\", err)\n+\t\t}\n+\t\tif err = client.Mail(fromAddr.String()), err != nil {\n \t\t\tt.Errorf(\"failed to set mail from address: %s\", err)\n \t\t}\n \t\texpected := \"MAIL FROM:<valid-from@domain.tld> SMTPUTF8\"\n",
                "@@ -2438,7 +2451,11 @@ func TestClient_Mail(t *testing.T) {\n \t\t\t\tt.Errorf(\"failed to close client: %s\", err)\n \t\t\t}\n \t\t})\n-\t\tif err = client.Mail(\"valid-from+\ud83d\udce7@domain.tld\"), err != nil {\n+\t\tfromAddr, err := netmail.ParseAddress(\"valid-from+\ud83d\udce7@domain.tld\")\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"failed to parse from address: %s\", err)\n+\t\t}\n+\t\tif err = client.Mail(fromAddr.String()), err != nil {\n \t\t\tt.Errorf(\"failed to set mail from address: %s\", err)\n \t\t}\n \t\texpected := \"MAIL FROM:<valid-from+\ud83d\udce7@domain.tld> SMTPUTF8\"\n",
                "@@ -2479,7 +2496,11 @@ func TestClient_Mail(t *testing.T) {\n \t\t\t}\n \t\t})\n \t\tclient.dsnmrtype = \"FULL\"\n-\t\tif err = client.Mail(\"valid-from@domain.tld\"), err != nil {\n+\t\tfromAddr, err := netmail.ParseAddress(\"valid-from@domain.tld\")\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"failed to parse from address: %s\", err)\n+\t\t}\n+\t\tif err = client.Mail(fromAddr.String()), err != nil {\n \t\t\tt.Errorf(\"failed to set mail from address: %s\", err)\n \t\t}\n \t\texpected := \"MAIL FROM:<valid-from@domain.tld> RET=FULL\"\n",
                "@@ -2520,7 +2541,11 @@ func TestClient_Mail(t *testing.T) {\n \t\t\t}\n \t\t})\n \t\tclient.dsnmrtype = \"FULL\"\n-\t\tif err = client.Mail(\"valid-from@domain.tld\"), err != nil {\n+\t\tfromAddr, err := netmail.ParseAddress(\"valid-from@domain.tld\")\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"failed to parse from address: %s\", err)\n+\t\t}\n+\t\tif err = client.Mail(fromAddr.String()), err != nil {\n \t\t\tt.Errorf(\"failed to set mail from address: %s\", err)\n \t\t}\n \t\texpected := \"MAIL FROM:<valid-from@domain.tld> BODY=8BITMIME SMTPUTF8 RET=FULL\"\n",
                "@@ -2560,7 +2585,11 @@ func TestClient_Rcpt(t *testing.T) {\n \t\t\t\tt.Errorf(\"failed to close client: %s\", err)\n \t\t\t}\n \t\t})\n-\t\tif err = client.Rcpt(\"valid-to@domain.tld\"), err != nil {\n+\t\taddr, err := netmail.ParseAddress(\"valid-to@domain.tld\")\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"failed to parse recipient address: %s\", err)\n+\t\t}\n+\t\tif err = client.Rcpt(addr.String()), err != nil {\n \t\t\tt.Errorf(\"failed to set recipient address: %s\", err)\n \t\t}\n \t})\n",
                "@@ -2626,7 +2655,11 @@ func TestClient_Rcpt(t *testing.T) {\n \t\t\tt.Fatalf(\"failed to send hello to test server: %s\", err)\n \t\t}\n \t\tclient.dsnrntype = \"SUCCESS\"\n-\t\tif err = client.Rcpt(\"valid-to@domain.tld\"), err == nil {\n+\t\taddr, err := netmail.ParseAddress(\"valid-to@domain.tld\")\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"failed to parse recipient address: %s\", err)\n+\t\t}\n+\t\tif err = client.Rcpt(addr.String()), err == nil {\n \t\t\tt.Error(\"recpient address with newlines should fail\")\n \t\t}\n \t\texpected := \"RCPT TO:<valid-to@domain.tld> NOTIFY=SUCCESS\"\n",
                "@@ -3006,8 +3039,16 @@ func TestSendMail(t *testing.T) {\n \t\t\tconfig.RootCAs = testConfig.RootCAs\n \t\t\tconfig.Certificates = testConfig.Certificates\n \t\t}\n+\t\tfromAddr, err := netmail.ParseAddress(\"valid-from@domain.tld\")\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"failed to parse from address: %s\", err)\n+\t\t}\n \t\tauth := LoginAuth(\"username\", \"password\", TestServerAddr, false)\n-\t\tif err := SendMail(addr, auth, \"valid-from@domain.tld\", []string{\"valid-to@domain.tld\"},\n+\t\ttoAddr, err := netmail.ParseAddress(\"valid-to@domain.tld\")\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"failed to parse recipient address: %s\", err)\n+\t\t}\n+\t\tif err := SendMail(addr, auth, fromAddr.String(), []string{toAddr.String()},\n \t\t\t[]byte(\"test message\")), err != nil {\n \t\t\tt.Fatalf(\"failed to send mail: %s\", err)\n \t\t}\n",
                "@@ -3090,8 +3131,16 @@ Subject: Hooray for Go\n Line 1\n .Leading dot line .\n Goodbye.`)\n+\t\tfromAddr, err := netmail.ParseAddress(\"valid-from@domain.tld\")\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"failed to parse from address: %s\", err)\n+\t\t}\n+\t\ttoAddr, err := netmail.ParseAddress(\"valid-to@domain.tld\")\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"failed to parse recipient address: %s\", err)\n+\t\t}\n \t\tauth := LoginAuth(\"username\", \"password\", TestServerAddr, false)\n-\t\tif err := SendMail(addr, auth, \"valid-from@domain.tld\", []string{\"valid-to@domain.tld\"}, message), err != nil {\n+\t\tif err = SendMail(addr, auth, fromAddr.String(), []string{toAddr.String()}, message), err != nil {\n \t\t\tt.Fatalf(\"failed to send mail: %s\", err)\n \t\t}\n \t\tprops.BufferMutex.RLock()"
            ]
        },
        "message": "Merge pull request #496 from wneessen/bugfix/495_mail-address-parsing  Fix vulnerability in mail address passing to the smtp client",
        "lines": [
            {
                "patch_index": 1,
                "lines": [
                    "client.dsnmrtype = \"SUCCESS\";"
                ]
            },
            {
                "patch_index": 2,
                "lines": [
                    "toAddr, err := netmail.ParseAddress(\"valid-to@domain.tld\");"
                ]
            },
            {
                "patch_index": 3,
                "lines": [
                    "fromAddr, err := netmail.ParseAddress(\"valid-from@domain.tld\");"
                ]
            }
        ]
    }
}