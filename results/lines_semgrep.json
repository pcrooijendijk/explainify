{
    "DataTables": {
        "path": "file_downloads/DataTables/old/examples.php",
        "lines": "echo htmlspecialchars( file_get_contents( '../server_side/'.$_POST['src'] ) );",
        "message_semgrep": "File name based on user input risks server-side request forgery.",
        "patches": [
            "@@ -1,6 +1,6 @@\n <?php\n \n-if ( isset( $_POST['src'] ) && preg_match( '/scripts\\/[a-zA-Z_\\-_]+\\.php/', $_POST['src'] ) !== 0 ) {\n+if ( isset( $_POST['src'] ) && preg_match( '/^scripts\\/[a-zA-Z_\\-_]+\\.php$/', $_POST['src'] ) !== 0 ) {\n \techo htmlspecialchars( file_get_contents( '../server_side/'.$_POST['src'] ) );\n }\n else {"
        ]
    },
    "KnowageLabs": {
        "path": "file_downloads/KnowageLabs/old/MetaService.java",
        "lines": "} catch (Throwable t) {",
        "message_semgrep": "Possible active debug code detected. Deploying an application with debug code can create unintended entry points or expose sensitive information.",
        "patches": [
            "@@ -110,6 +110,7 @@\n import it.eng.knowage.meta.model.physical.PhysicalTable;\n import it.eng.knowage.meta.model.serializer.EmfXmiSerializer;\n import it.eng.knowage.meta.model.serializer.ModelPropertyFactory;\n+import it.eng.knowage.meta.model.util.JXPathContextBuilder;\n import it.eng.qbe.utility.CustomFunctionsSingleton;\n import it.eng.qbe.utility.CustomizedFunctionsReader;\n import it.eng.qbe.utility.DbTypeThreadLocal;\n@@ -214,7 +215,8 @@ public Response loadSbiModel(@PathParam(\"bmId\") Integer bmId, @Context HttpServl\n \n \t\t\treturn Response.ok(translatedModel.toString()).build();\n \n-\t\t} catch (Throwable t) {\r\t\t\tlogger.error(\"Impossibile to load the model\", t);\n+\t\t} catch (Throwable t) {\n+\t\t\tlogger.error(\"Impossibile to load the model\", t);\n \t\t\tthrow new SpagoBIServiceException(req.getPathInfo(), t);\n \t\t}\n \t}\n@@ -1491,8 +1493,7 @@ private void applyDiff(JSONObject jsonRoot, Model model) throws SpagoBIException\n \tprivate void applyPatch(JsonNode patch, Model model) throws SpagoBIException {\n \t\tlogger.debug(\"applyPatch:\" + patch != null ? patch.toString() : \"null\");\n \t\tIterator<JsonNode> elements = patch.elements();\n-\t\tJXPathContext context = JXPathContext.newContext(model);\n-\t\tcontext.setFactory(new ModelPropertyFactory());\n+\t\tJXPathContext context = JXPathContextBuilder.newInstance(model).withFactory(new ModelPropertyFactory()).build();\n \t\twhile (elements.hasNext()) {\n \t\t\tJsonNode jsonNode = elements.next();\n \t\t\tString operation = jsonNode.get(\"op\").textValue();"
        ]
    },
    "auth0": {
        "path": "file_downloads/auth0/new/HttpRequestTest.php",
        "lines": "@unlink($tempFile);",
        "message_semgrep": "Using user input when deleting files with `unlink()` is potentially dangerous. A malicious actor could use this to modify or access files they have no right to.",
        "patches": [
            "@@ -176,6 +176,56 @@ function(): HttpRequest {\n     fn() => new HttpRequest($this->configuration, HttpClient::CONTEXT_GENERIC_CLIENT, 'get', '/' . uniqid())\n ]]);\n \n+it('rejects file paths with protocol separators', function(): void {\n+    $client = new HttpRequest($this->configuration, HttpClient::CONTEXT_GENERIC_CLIENT, 'post', '/');\n+    \n+    expect(fn() => $client->addFile('test', 'file:///etc/passwd'))\n+        ->toThrow(\\InvalidArgumentException::class, 'File paths with protocol separators (\"://\") are not allowed: \"file:///etc/passwd\"');\n+        \n+    expect(fn() => $client->addFile('test', 'http://example.com/file.txt'))\n+        ->toThrow(\\InvalidArgumentException::class, 'File paths with protocol separators (\"://\") are not allowed: \"http://example.com/file.txt\"');\n+        \n+    expect(fn() => $client->addFile('test', 'php://filter/convert.base64-encode/resource=/etc/passwd'))\n+        ->toThrow(\\InvalidArgumentException::class, 'File paths with protocol separators (\"://\") are not allowed: \"php://filter/convert.base64-encode/resource=/etc/passwd\"');\n+});\n+\n+it('rejects file paths for non-existent or unreadable files', function(): void {\n+    $client = new HttpRequest($this->configuration, HttpClient::CONTEXT_GENERIC_CLIENT, 'post', '/');\n+    \n+    // Non-existent file\n+    expect(fn() => $client->addFile('test', '/non/existent/file.txt'))\n+        ->toThrow(\\InvalidArgumentException::class, 'The file \"/non/existent/file.txt\" does not exist.');\n+    \n+    // Create a temp file with no read permissions to test unreadable file\n+    $tempFile = sys_get_temp_dir() . '/' . uniqid('auth0_test_');\n+    file_put_contents($tempFile, 'test content');\n+    chmod($tempFile, 0000); // Remove all permissions\n+    \n+    try {\n+        expect(fn() => $client->addFile('test', $tempFile))\n+            ->toThrow(\\InvalidArgumentException::class);\n+    } finally {\n+        chmod($tempFile, 0666); // Restore permissions so we can delete it\n+        @unlink($tempFile);\n+    }\n+});\n+\n+it('allows valid local file paths', function(): void {\n+    $client = new HttpRequest($this->configuration, HttpClient::CONTEXT_GENERIC_CLIENT, 'post', '/');\n+    \n+    // Create a temporary file that exists and is readable\n+    $tempFile = sys_get_temp_dir() . '/' . uniqid('auth0_test_');\n+    file_put_contents($tempFile, 'test content');\n+    \n+    try {\n+        // This should not throw an exception\n+        $result = $client->addFile('test', $tempFile);\n+        expect($result)->toBeInstanceOf(HttpRequest::class);\n+    } finally {\n+        @unlink($tempFile);\n+    }\n+});\n+\n it('throws a NetworkException when the underlying client raises a ClientExceptionInterface', function(HttpRequest $client): void {\n     $client->call();\n })->with(['mocked client' => ["
        ]
    },
    "formbricks": {
        "path": "file_downloads/formbricks/new/jwt.test.ts",
        "lines": "TEST_NEXTAUTH_SECRET + mockUser.email",
        "message_semgrep": "A hard-coded credential was detected. It is not recommended to store credentials in source-code, as this risks secrets being leaked and used by either an internal or external malicious adversary. It is recommended to use environment variables to securely provide credentials or retrieve credentials from a secure vault or HSM (Hardware Security Module).",
        "patches": [
            "@@ -1,6 +1,7 @@\n-import { env } from \"@/lib/env\";\n+import jwt from \"jsonwebtoken\";\n import { beforeEach, describe, expect, test, vi } from \"vitest\";\n import { prisma } from \"@formbricks/database\";\n+import * as crypto from \"@/lib/crypto\";\n import {\n   createEmailChangeToken,\n   createEmailToken,\n@@ -14,12 +15,69 @@ import {\n   verifyTokenForLinkSurvey,\n } from \"./jwt\";\n \n+const TEST_ENCRYPTION_KEY = \"0\".repeat(32); // 32-byte key for AES-256-GCM\n+const TEST_NEXTAUTH_SECRET = \"test-nextauth-secret\";\n+const DIFFERENT_SECRET = \"different-secret\";\n+\n+// Error message constants\n+const NEXTAUTH_SECRET_ERROR = \"NEXTAUTH_SECRET is not set\";\n+const ENCRYPTION_KEY_ERROR = \"ENCRYPTION_KEY is not set\";\n+\n+// Helper function to test error cases for missing secrets/keys\n+const testMissingSecretsError = async (\n+  testFn: (...args: any[]) => any,\n+  args: any[],\n+  options: {\n+    testNextAuthSecret?: boolean;\n+    testEncryptionKey?: boolean;\n+    isAsync?: boolean;\n+  } = {}\n+) => {\n+  const { testNextAuthSecret = true, testEncryptionKey = true, isAsync = false } = options;\n+\n+  if (testNextAuthSecret) {\n+    const constants = await import(\"@/lib/constants\");\n+    const originalSecret = (constants as any).NEXTAUTH_SECRET;\n+    (constants as any).NEXTAUTH_SECRET = undefined;\n+\n+    if (isAsync) {\n+      await expect(testFn(...args)).rejects.toThrow(NEXTAUTH_SECRET_ERROR);\n+    } else {\n+      expect(() => testFn(...args)).toThrow(NEXTAUTH_SECRET_ERROR);\n+    }\n+\n+    // Restore\n+    (constants as any).NEXTAUTH_SECRET = originalSecret;\n+  }\n+\n+  if (testEncryptionKey) {\n+    const constants = await import(\"@/lib/constants\");\n+    const originalKey = (constants as any).ENCRYPTION_KEY;\n+    (constants as any).ENCRYPTION_KEY = undefined;\n+\n+    if (isAsync) {\n+      await expect(testFn(...args)).rejects.toThrow(ENCRYPTION_KEY_ERROR);\n+    } else {\n+      expect(() => testFn(...args)).toThrow(ENCRYPTION_KEY_ERROR);\n+    }\n+\n+    // Restore\n+    (constants as any).ENCRYPTION_KEY = originalKey;\n+  }\n+};\n+\n // Mock environment variables\n vi.mock(\"@/lib/env\", () => ({\n   env: {\n-    ENCRYPTION_KEY: \"0\".repeat(32), // 32-byte key for AES-256-GCM\n+    ENCRYPTION_KEY: \"0\".repeat(32),\n     NEXTAUTH_SECRET: \"test-nextauth-secret\",\n-  } as typeof env,\n+  },\n+}));\n+\n+// Mock constants\n+vi.mock(\"@/lib/constants\", () => ({\n+  NEXTAUTH_SECRET: \"test-nextauth-secret\",\n+  ENCRYPTION_KEY: \"0\".repeat(32),\n }));\n \n // Mock prisma\n@@ -31,22 +89,65 @@ vi.mock(\"@formbricks/database\", () => ({\n   },\n }));\n \n-describe(\"JWT Functions\", () => {\n+// Mock logger\n+vi.mock(\"@formbricks/logger\", () => ({\n+  logger: {\n+    error: vi.fn(),\n+    warn: vi.fn(),\n+    info: vi.fn(),\n+  },\n+}));\n+\n+describe(\"JWT Functions - Comprehensive Security Tests\", () => {\n   const mockUser = {\n     id: \"test-user-id\",\n     email: \"test@example.com\",\n   };\n \n+  let mockSymmetricEncrypt: any;\n+  let mockSymmetricDecrypt: any;\n+\n   beforeEach(() => {\n     vi.clearAllMocks();\n+\n+    // Setup default crypto mocks\n+    mockSymmetricEncrypt = vi\n+      .spyOn(crypto, \"symmetricEncrypt\")\n+      .mockImplementation((text: string) => `encrypted_${text}`);\n+\n+    mockSymmetricDecrypt = vi\n+      .spyOn(crypto, \"symmetricDecrypt\")\n+      .mockImplementation((encryptedText: string) => encryptedText.replace(\"encrypted_\", \"\"));\n+\n     (prisma.user.findUnique as any).mockResolvedValue(mockUser);\n   });\n \n   describe(\"createToken\", () => {\n-    test(\"should create a valid token\", () => {\n-      const token = createToken(mockUser.id, mockUser.email);\n+    test(\"should create a valid token with encrypted user ID\", () => {\n+      const token = createToken(mockUser.id);\n       expect(token).toBeDefined();\n       expect(typeof token).toBe(\"string\");\n+      expect(mockSymmetricEncrypt).toHaveBeenCalledWith(mockUser.id, TEST_ENCRYPTION_KEY);\n+    });\n+\n+    test(\"should accept custom options\", () => {\n+      const customOptions = { expiresIn: \"1h\" };\n+      const token = createToken(mockUser.id, customOptions);\n+      expect(token).toBeDefined();\n+\n+      // Verify the token contains the expected expiration\n+      const decoded = jwt.decode(token) as any;\n+      expect(decoded.exp).toBeDefined();\n+      expect(decoded.iat).toBeDefined();\n+      // Should expire in approximately 1 hour (3600 seconds)\n+      expect(decoded.exp - decoded.iat).toBe(3600);\n+    });\n+\n+    test(\"should throw error if NEXTAUTH_SECRET is not set\", async () => {\n+      await testMissingSecretsError(createToken, [mockUser.id], {\n+        testNextAuthSecret: true,\n+        testEncryptionKey: false,\n+      });\n     });\n   });\n \n@@ -56,6 +157,18 @@ describe(\"JWT Functions\", () => {\n       const token = createTokenForLinkSurvey(surveyId, mockUser.email);\n       expect(token).toBeDefined();\n       expect(typeof token).toBe(\"string\");\n+      expect(mockSymmetricEncrypt).toHaveBeenCalledWith(mockUser.email, TEST_ENCRYPTION_KEY);\n+    });\n+\n+    test(\"should include surveyId in payload\", () => {\n+      const surveyId = \"test-survey-id\";\n+      const token = createTokenForLinkSurvey(surveyId, mockUser.email);\n+      const decoded = jwt.decode(token) as any;\n+      expect(decoded.surveyId).toBe(surveyId);\n+    });\n+\n+    test(\"should throw error if NEXTAUTH_SECRET or ENCRYPTION_KEY is not set\", async () => {\n+      await testMissingSecretsError(createTokenForLinkSurvey, [\"survey-id\", mockUser.email]);\n     });\n   });\n \n@@ -64,24 +177,30 @@ describe(\"JWT Functions\", () => {\n       const token = createEmailToken(mockUser.email);\n       expect(token).toBeDefined();\n       expect(typeof token).toBe(\"string\");\n+      expect(mockSymmetricEncrypt).toHaveBeenCalledWith(mockUser.email, TEST_ENCRYPTION_KEY);\n     });\n \n-    test(\"should throw error if NEXTAUTH_SECRET is not set\", () => {\n-      const originalSecret = env.NEXTAUTH_SECRET;\n-      try {\n-        (env as any).NEXTAUTH_SECRET = undefined;\n-        expect(() => createEmailToken(mockUser.email)).toThrow(\"NEXTAUTH_SECRET is not set\");\n-      } finally {\n-        (env as any).NEXTAUTH_SECRET = originalSecret;\n-      }\n+    test(\"should throw error if NEXTAUTH_SECRET or ENCRYPTION_KEY is not set\", async () => {\n+      await testMissingSecretsError(createEmailToken, [mockUser.email]);\n     });\n   });\n \n-  describe(\"getEmailFromEmailToken\", () => {\n-    test(\"should extract email from valid token\", () => {\n-      const token = createEmailToken(mockUser.email);\n-      const extractedEmail = getEmailFromEmailToken(token);\n-      expect(extractedEmail).toBe(mockUser.email);\n+  describe(\"createEmailChangeToken\", () => {\n+    test(\"should create a valid email change token with 1 day expiration\", () => {\n+      const token = createEmailChangeToken(mockUser.id, mockUser.email);\n+      expect(token).toBeDefined();\n+      expect(mockSymmetricEncrypt).toHaveBeenCalledWith(mockUser.id, TEST_ENCRYPTION_KEY);\n+      expect(mockSymmetricEncrypt).toHaveBeenCalledWith(mockUser.email, TEST_ENCRYPTION_KEY);\n+\n+      const decoded = jwt.decode(token) as any;\n+      expect(decoded.exp).toBeDefined();\n+      expect(decoded.iat).toBeDefined();\n+      // Should expire in approximately 1 day (86400 seconds)\n+      expect(decoded.exp - decoded.iat).toBe(86400);\n+    });\n+\n+    test(\"should throw error if NEXTAUTH_SECRET or ENCRYPTION_KEY is not set\", async () => {\n+      await testMissingSecretsError(createEmailChangeToken, [mockUser.id, mockUser.email]);\n     });\n   });\n \n@@ -91,6 +210,50 @@ describe(\"JWT Functions\", () => {\n       const token = createInviteToken(inviteId, mockUser.email);\n       expect(token).toBeDefined();\n       expect(typeof token).toBe(\"string\");\n+      expect(mockSymmetricEncrypt).toHaveBeenCalledWith(inviteId, TEST_ENCRYPTION_KEY);\n+      expect(mockSymmetricEncrypt).toHaveBeenCalledWith(mockUser.email, TEST_ENCRYPTION_KEY);\n+    });\n+\n+    test(\"should accept custom options\", () => {\n+      const inviteId = \"test-invite-id\";\n+      const customOptions = { expiresIn: \"24h\" };\n+      const token = createInviteToken(inviteId, mockUser.email, customOptions);\n+      expect(token).toBeDefined();\n+\n+      const decoded = jwt.decode(token) as any;\n+      expect(decoded.exp).toBeDefined();\n+      expect(decoded.iat).toBeDefined();\n+      // Should expire in approximately 24 hours (86400 seconds)\n+      expect(decoded.exp - decoded.iat).toBe(86400);\n+    });\n+\n+    test(\"should throw error if NEXTAUTH_SECRET or ENCRYPTION_KEY is not set\", async () => {\n+      await testMissingSecretsError(createInviteToken, [\"invite-id\", mockUser.email]);\n+    });\n+  });\n+\n+  describe(\"getEmailFromEmailToken\", () => {\n+    test(\"should extract email from valid token\", () => {\n+      const token = createEmailToken(mockUser.email);\n+      const extractedEmail = getEmailFromEmailToken(token);\n+      expect(extractedEmail).toBe(mockUser.email);\n+      expect(mockSymmetricDecrypt).toHaveBeenCalledWith(`encrypted_${mockUser.email}`, TEST_ENCRYPTION_KEY);\n+    });\n+\n+    test(\"should fall back to original email if decryption fails\", () => {\n+      mockSymmetricDecrypt.mockImplementationOnce(() => {\n+        throw new Error(\"Decryption failed\");\n+      });\n+\n+      // Create token manually with unencrypted email for legacy compatibility\n+      const legacyToken = jwt.sign({ email: mockUser.email }, TEST_NEXTAUTH_SECRET);\n+      const extractedEmail = getEmailFromEmailToken(legacyToken);\n+      expect(extractedEmail).toBe(mockUser.email);\n+    });\n+\n+    test(\"should throw error if NEXTAUTH_SECRET or ENCRYPTION_KEY is not set\", async () => {\n+      const token = jwt.sign({ email: \"test@example.com\" }, TEST_NEXTAUTH_SECRET);\n+      await testMissingSecretsError(getEmailFromEmailToken, [token]);\n     });\n   });\n \n@@ -106,23 +269,194 @@ describe(\"JWT Functions\", () => {\n       const result = verifyTokenForLinkSurvey(\"invalid-token\", \"test-survey-id\");\n       expect(result).toBeNull();\n     });\n+\n+    test(\"should return null if NEXTAUTH_SECRET is not set\", async () => {\n+      const constants = await import(\"@/lib/constants\");\n+      const originalSecret = (constants as any).NEXTAUTH_SECRET;\n+      (constants as any).NEXTAUTH_SECRET = undefined;\n+\n+      const result = verifyTokenForLinkSurvey(\"any-token\", \"test-survey-id\");\n+      expect(result).toBeNull();\n+\n+      // Restore\n+      (constants as any).NEXTAUTH_SECRET = originalSecret;\n+    });\n+\n+    test(\"should return null if surveyId doesn't match\", () => {\n+      const surveyId = \"test-survey-id\";\n+      const differentSurveyId = \"different-survey-id\";\n+      const token = createTokenForLinkSurvey(surveyId, mockUser.email);\n+      const result = verifyTokenForLinkSurvey(token, differentSurveyId);\n+      expect(result).toBeNull();\n+    });\n+\n+    test(\"should return null if email is missing from payload\", () => {\n+      const tokenWithoutEmail = jwt.sign({ surveyId: \"test-survey-id\" }, TEST_NEXTAUTH_SECRET);\n+      const result = verifyTokenForLinkSurvey(tokenWithoutEmail, \"test-survey-id\");\n+      expect(result).toBeNull();\n+    });\n+\n+    test(\"should fall back to original email if decryption fails\", () => {\n+      mockSymmetricDecrypt.mockImplementationOnce(() => {\n+        throw new Error(\"Decryption failed\");\n+      });\n+\n+      // Create legacy token with unencrypted email\n+      const legacyToken = jwt.sign(\n+        {\n+          email: mockUser.email,\n+          surveyId: \"test-survey-id\",\n+        },\n+        TEST_NEXTAUTH_SECRET\n+      );\n+\n+      const result = verifyTokenForLinkSurvey(legacyToken, \"test-survey-id\");\n+      expect(result).toBe(mockUser.email);\n+    });\n+\n+    test(\"should fall back to original email if ENCRYPTION_KEY is not set\", async () => {\n+      const constants = await import(\"@/lib/constants\");\n+      const originalKey = (constants as any).ENCRYPTION_KEY;\n+      (constants as any).ENCRYPTION_KEY = undefined;\n+\n+      // Create a token with unencrypted email (as it would be if ENCRYPTION_KEY was not set during creation)\n+      const token = jwt.sign(\n+        {\n+          email: mockUser.email,\n+          surveyId: \"survey-id\",\n+        },\n+        TEST_NEXTAUTH_SECRET\n+      );\n+\n+      const result = verifyTokenForLinkSurvey(token, \"survey-id\");\n+      expect(result).toBe(mockUser.email);\n+\n+      // Restore\n+      (constants as any).ENCRYPTION_KEY = originalKey;\n+    });\n+\n+    test(\"should verify legacy survey tokens with surveyId-based secret\", async () => {\n+      const surveyId = \"test-survey-id\";\n+\n+      // Create legacy token with old format (NEXTAUTH_SECRET + surveyId)\n+      const legacyToken = jwt.sign({ email: `encrypted_${mockUser.email}` }, TEST_NEXTAUTH_SECRET + surveyId);\n+\n+      const result = verifyTokenForLinkSurvey(legacyToken, surveyId);\n+      expect(result).toBe(mockUser.email);\n+    });\n+\n+    test(\"should reject survey tokens that fail both new and legacy verification\", async () => {\n+      const surveyId = \"test-survey-id\";\n+      const invalidToken = jwt.sign({ email: \"encrypted_test@example.com\" }, \"wrong-secret\");\n+\n+      const result = verifyTokenForLinkSurvey(invalidToken, surveyId);\n+      expect(result).toBeNull();\n+\n+      // Verify error logging\n+      const { logger } = await import(\"@formbricks/logger\");\n+      expect(logger.error).toHaveBeenCalledWith(expect.any(Error), \"Survey link token verification failed\");\n+    });\n+\n+    test(\"should reject legacy survey tokens for wrong survey\", () => {\n+      const correctSurveyId = \"correct-survey-id\";\n+      const wrongSurveyId = \"wrong-survey-id\";\n+\n+      // Create legacy token for one survey\n+      const legacyToken = jwt.sign(\n+        { email: `encrypted_${mockUser.email}` },\n+        TEST_NEXTAUTH_SECRET + correctSurveyId\n+      );\n+\n+      // Try to verify with different survey ID\n+      const result = verifyTokenForLinkSurvey(legacyToken, wrongSurveyId);\n+      expect(result).toBeNull();\n+    });\n   });\n \n   describe(\"verifyToken\", () => {\n     test(\"should verify valid token\", async () => {\n-      const token = createToken(mockUser.id, mockUser.email);\n+      const token = createToken(mockUser.id);\n       const verified = await verifyToken(token);\n       expect(verified).toEqual({\n-        id: mockUser.id,\n+        id: mockUser.id, // Returns the decrypted user ID\n         email: mockUser.email,\n       });\n     });\n \n     test(\"should throw error if user not found\", async () => {\n       (prisma.user.findUnique as any).mockResolvedValue(null);\n-      const token = createToken(mockUser.id, mockUser.email);\n+      const token = createToken(mockUser.id);\n       await expect(verifyToken(token)).rejects.toThrow(\"User not found\");\n     });\n+\n+    test(\"should throw error if NEXTAUTH_SECRET is not set\", async () => {\n+      await testMissingSecretsError(verifyToken, [\"any-token\"], {\n+        testNextAuthSecret: true,\n+        testEncryptionKey: false,\n+        isAsync: true,\n+      });\n+    });\n+\n+    test(\"should throw error for invalid token signature\", async () => {\n+      const invalidToken = jwt.sign({ id: \"test-id\" }, DIFFERENT_SECRET);\n+      await expect(verifyToken(invalidToken)).rejects.toThrow(\"Invalid token\");\n+    });\n+\n+    test(\"should throw error if token payload is missing id\", async () => {\n+      const tokenWithoutId = jwt.sign({ email: mockUser.email }, TEST_NEXTAUTH_SECRET);\n+      await expect(verifyToken(tokenWithoutId)).rejects.toThrow(\"Invalid token\");\n+    });\n+\n+    test(\"should return raw id from payload\", async () => {\n+      // Create token with unencrypted id\n+      const token = jwt.sign({ id: mockUser.id }, TEST_NEXTAUTH_SECRET);\n+      const verified = await verifyToken(token);\n+      expect(verified).toEqual({\n+        id: mockUser.id, // Returns the raw ID from payload\n+        email: mockUser.email,\n+      });\n+    });\n+\n+    test(\"should verify legacy tokens with email-based secret\", async () => {\n+      // Create legacy token with old format (NEXTAUTH_SECRET + userEmail)\n+      const legacyToken = jwt.sign({ id: `encrypted_${mockUser.id}` }, TEST_NEXTAUTH_SECRET + mockUser.email);\n+\n+      const verified = await verifyToken(legacyToken);\n+      expect(verified).toEqual({\n+        id: mockUser.id, // Returns the decrypted user ID\n+        email: mockUser.email,\n+      });\n+    });\n+\n+    test(\"should prioritize new tokens over legacy tokens\", async () => {\n+      // Create both new and legacy tokens for the same user\n+      const newToken = createToken(mockUser.id);\n+      const legacyToken = jwt.sign({ id: `encrypted_${mockUser.id}` }, TEST_NEXTAUTH_SECRET + mockUser.email);\n+\n+      // New token should verify without triggering legacy path\n+      const verifiedNew = await verifyToken(newToken);\n+      expect(verifiedNew.id).toBe(mockUser.id); // Returns decrypted user ID\n+\n+      // Legacy token should trigger legacy path\n+      const verifiedLegacy = await verifyToken(legacyToken);\n+      expect(verifiedLegacy.id).toBe(mockUser.id); // Returns decrypted user ID\n+    });\n+\n+    test(\"should reject tokens that fail both new and legacy verification\", async () => {\n+      const invalidToken = jwt.sign({ id: \"encrypted_test-id\" }, \"wrong-secret\");\n+      await expect(verifyToken(invalidToken)).rejects.toThrow(\"Invalid token\");\n+\n+      // Verify both methods were attempted\n+      const { logger } = await import(\"@formbricks/logger\");\n+      expect(logger.error).toHaveBeenCalledWith(\n+        expect.any(Error),\n+        \"Token verification failed with new method\"\n+      );\n+      expect(logger.error).toHaveBeenCalledWith(\n+        expect.any(Error),\n+        \"Token verification failed with legacy method\"\n+      );\n+    });\n   });\n \n   describe(\"verifyInviteToken\", () => {\n@@ -139,6 +473,53 @@ describe(\"JWT Functions\", () => {\n     test(\"should throw error for invalid token\", () => {\n       expect(() => verifyInviteToken(\"invalid-token\")).toThrow(\"Invalid or expired invite token\");\n     });\n+\n+    test(\"should throw error if NEXTAUTH_SECRET or ENCRYPTION_KEY is not set\", async () => {\n+      await testMissingSecretsError(verifyInviteToken, [\"any-token\"]);\n+    });\n+\n+    test(\"should throw error if inviteId is missing\", () => {\n+      const tokenWithoutInviteId = jwt.sign({ email: mockUser.email }, TEST_NEXTAUTH_SECRET);\n+      expect(() => verifyInviteToken(tokenWithoutInviteId)).toThrow(\"Invalid or expired invite token\");\n+    });\n+\n+    test(\"should throw error if email is missing\", () => {\n+      const tokenWithoutEmail = jwt.sign({ inviteId: \"test-invite-id\" }, TEST_NEXTAUTH_SECRET);\n+      expect(() => verifyInviteToken(tokenWithoutEmail)).toThrow(\"Invalid or expired invite token\");\n+    });\n+\n+    test(\"should fall back to original values if decryption fails\", () => {\n+      mockSymmetricDecrypt.mockImplementation(() => {\n+        throw new Error(\"Decryption failed\");\n+      });\n+\n+      const inviteId = \"test-invite-id\";\n+      const legacyToken = jwt.sign(\n+        {\n+          inviteId,\n+          email: mockUser.email,\n+        },\n+        TEST_NEXTAUTH_SECRET\n+      );\n+\n+      const verified = verifyInviteToken(legacyToken);\n+      expect(verified).toEqual({\n+        inviteId,\n+        email: mockUser.email,\n+      });\n+    });\n+\n+    test(\"should throw error for token with wrong signature\", () => {\n+      const invalidToken = jwt.sign(\n+        {\n+          inviteId: \"test-invite-id\",\n+          email: mockUser.email,\n+        },\n+        DIFFERENT_SECRET\n+      );\n+\n+      expect(() => verifyInviteToken(invalidToken)).toThrow(\"Invalid or expired invite token\");\n+    });\n   });\n \n   describe(\"verifyEmailChangeToken\", () => {\n@@ -150,22 +531,478 @@ describe(\"JWT Functions\", () => {\n       expect(result).toEqual({ id: userId, email });\n     });\n \n+    test(\"should throw error if NEXTAUTH_SECRET or ENCRYPTION_KEY is not set\", async () => {\n+      await testMissingSecretsError(verifyEmailChangeToken, [\"any-token\"], { isAsync: true });\n+    });\n+\n     test(\"should throw error if token is invalid or missing fields\", async () => {\n-      // Create a token with missing fields\n-      const jwt = await import(\"jsonwebtoken\");\n-      const token = jwt.sign({ foo: \"bar\" }, env.NEXTAUTH_SECRET as string);\n+      const token = jwt.sign({ foo: \"bar\" }, TEST_NEXTAUTH_SECRET);\n+      await expect(verifyEmailChangeToken(token)).rejects.toThrow(\n+        \"Token is invalid or missing required fields\"\n+      );\n+    });\n+\n+    test(\"should throw error if id is missing\", async () => {\n+      const token = jwt.sign({ email: \"test@example.com\" }, TEST_NEXTAUTH_SECRET);\n+      await expect(verifyEmailChangeToken(token)).rejects.toThrow(\n+        \"Token is invalid or missing required fields\"\n+      );\n+    });\n+\n+    test(\"should throw error if email is missing\", async () => {\n+      const token = jwt.sign({ id: \"test-id\" }, TEST_NEXTAUTH_SECRET);\n       await expect(verifyEmailChangeToken(token)).rejects.toThrow(\n         \"Token is invalid or missing required fields\"\n       );\n     });\n \n     test(\"should return original id/email if decryption fails\", async () => {\n-      // Create a token with non-encrypted id/email\n-      const jwt = await import(\"jsonwebtoken\");\n+      mockSymmetricDecrypt.mockImplementation(() => {\n+        throw new Error(\"Decryption failed\");\n+      });\n+\n       const payload = { id: \"plain-id\", email: \"plain@example.com\" };\n-      const token = jwt.sign(payload, env.NEXTAUTH_SECRET as string);\n+      const token = jwt.sign(payload, TEST_NEXTAUTH_SECRET);\n       const result = await verifyEmailChangeToken(token);\n       expect(result).toEqual(payload);\n     });\n+\n+    test(\"should throw error for token with wrong signature\", async () => {\n+      const invalidToken = jwt.sign(\n+        {\n+          id: \"test-id\",\n+          email: \"test@example.com\",\n+        },\n+        DIFFERENT_SECRET\n+      );\n+\n+      await expect(verifyEmailChangeToken(invalidToken)).rejects.toThrow();\n+    });\n+  });\n+\n+  // SECURITY SCENARIO TESTS\n+  describe(\"Security Scenarios\", () => {\n+    describe(\"Algorithm Confusion Attack Prevention\", () => {\n+      test(\"should reject 'none' algorithm tokens in verifyToken\", async () => {\n+        // Create malicious token with \"none\" algorithm\n+        const maliciousToken =\n+          Buffer.from(\n+            JSON.stringify({\n+              alg: \"none\",\n+              typ: \"JWT\",\n+            })\n+          ).toString(\"base64url\") +\n+          \".\" +\n+          Buffer.from(\n+            JSON.stringify({\n+              id: \"encrypted_malicious-id\",\n+            })\n+          ).toString(\"base64url\") +\n+          \".\";\n+\n+        await expect(verifyToken(maliciousToken)).rejects.toThrow(\"Invalid token\");\n+      });\n+\n+      test(\"should reject 'none' algorithm tokens in verifyTokenForLinkSurvey\", () => {\n+        const maliciousToken =\n+          Buffer.from(\n+            JSON.stringify({\n+              alg: \"none\",\n+              typ: \"JWT\",\n+            })\n+          ).toString(\"base64url\") +\n+          \".\" +\n+          Buffer.from(\n+            JSON.stringify({\n+              email: \"encrypted_attacker@evil.com\",\n+              surveyId: \"test-survey-id\",\n+            })\n+          ).toString(\"base64url\") +\n+          \".\";\n+\n+        const result = verifyTokenForLinkSurvey(maliciousToken, \"test-survey-id\");\n+        expect(result).toBeNull();\n+      });\n+\n+      test(\"should reject 'none' algorithm tokens in verifyInviteToken\", () => {\n+        const maliciousToken =\n+          Buffer.from(\n+            JSON.stringify({\n+              alg: \"none\",\n+              typ: \"JWT\",\n+            })\n+          ).toString(\"base64url\") +\n+          \".\" +\n+          Buffer.from(\n+            JSON.stringify({\n+              inviteId: \"encrypted_malicious-invite\",\n+              email: \"encrypted_attacker@evil.com\",\n+            })\n+          ).toString(\"base64url\") +\n+          \".\";\n+\n+        expect(() => verifyInviteToken(maliciousToken)).toThrow(\"Invalid or expired invite token\");\n+      });\n+\n+      test(\"should reject 'none' algorithm tokens in verifyEmailChangeToken\", async () => {\n+        const maliciousToken =\n+          Buffer.from(\n+            JSON.stringify({\n+              alg: \"none\",\n+              typ: \"JWT\",\n+            })\n+          ).toString(\"base64url\") +\n+          \".\" +\n+          Buffer.from(\n+            JSON.stringify({\n+              id: \"encrypted_malicious-id\",\n+              email: \"encrypted_attacker@evil.com\",\n+            })\n+          ).toString(\"base64url\") +\n+          \".\";\n+\n+        await expect(verifyEmailChangeToken(maliciousToken)).rejects.toThrow();\n+      });\n+\n+      test(\"should reject RS256 algorithm tokens (HS256/RS256 confusion)\", async () => {\n+        // Create malicious token with RS256 algorithm header but HS256 signature\n+        const maliciousHeader = Buffer.from(\n+          JSON.stringify({\n+            alg: \"RS256\",\n+            typ: \"JWT\",\n+          })\n+        ).toString(\"base64url\");\n+\n+        const maliciousPayload = Buffer.from(\n+          JSON.stringify({\n+            id: \"encrypted_malicious-id\",\n+          })\n+        ).toString(\"base64url\");\n+\n+        // Create signature using HMAC (as if it were HS256)\n+        const crypto = require(\"crypto\");\n+        const signature = crypto\n+          .createHmac(\"sha256\", TEST_NEXTAUTH_SECRET)\n+          .update(`${maliciousHeader}.${maliciousPayload}`)\n+          .digest(\"base64url\");\n+\n+        const maliciousToken = `${maliciousHeader}.${maliciousPayload}.${signature}`;\n+\n+        await expect(verifyToken(maliciousToken)).rejects.toThrow(\"Invalid token\");\n+      });\n+\n+      test(\"should only accept HS256 algorithm\", async () => {\n+        // Test that other valid algorithms are rejected\n+        const otherAlgorithms = [\"HS384\", \"HS512\", \"RS256\", \"RS384\", \"RS512\", \"ES256\", \"ES384\", \"ES512\"];\n+\n+        for (const alg of otherAlgorithms) {\n+          const maliciousHeader = Buffer.from(\n+            JSON.stringify({\n+              alg,\n+              typ: \"JWT\",\n+            })\n+          ).toString(\"base64url\");\n+\n+          const maliciousPayload = Buffer.from(\n+            JSON.stringify({\n+              id: \"encrypted_test-id\",\n+            })\n+          ).toString(\"base64url\");\n+\n+          const maliciousToken = `${maliciousHeader}.${maliciousPayload}.fake-signature`;\n+\n+          await expect(verifyToken(maliciousToken)).rejects.toThrow(\"Invalid token\");\n+        }\n+      });\n+    });\n+\n+    describe(\"Token Tampering\", () => {\n+      test(\"should reject tokens with modified payload\", async () => {\n+        const token = createToken(mockUser.id);\n+        const [header, payload, signature] = token.split(\".\");\n+\n+        // Modify the payload\n+        const decodedPayload = JSON.parse(Buffer.from(payload, \"base64url\").toString());\n+        decodedPayload.id = \"malicious-id\";\n+        const tamperedPayload = Buffer.from(JSON.stringify(decodedPayload)).toString(\"base64url\");\n+        const tamperedToken = `${header}.${tamperedPayload}.${signature}`;\n+\n+        await expect(verifyToken(tamperedToken)).rejects.toThrow(\"Invalid token\");\n+      });\n+\n+      test(\"should reject tokens with modified signature\", async () => {\n+        const token = createToken(mockUser.id);\n+        const [header, payload] = token.split(\".\");\n+        const tamperedToken = `${header}.${payload}.tamperedsignature`;\n+\n+        await expect(verifyToken(tamperedToken)).rejects.toThrow(\"Invalid token\");\n+      });\n+\n+      test(\"should reject malformed tokens\", async () => {\n+        const malformedTokens = [\n+          \"not.a.jwt\",\n+          \"only.two.parts\",\n+          \"too.many.parts.here.invalid\",\n+          \"\",\n+          \"invalid-base64\",\n+        ];\n+\n+        for (const malformedToken of malformedTokens) {\n+          await expect(verifyToken(malformedToken)).rejects.toThrow();\n+        }\n+      });\n+    });\n+\n+    describe(\"Cross-Survey Token Reuse\", () => {\n+      test(\"should reject survey tokens used for different surveys\", () => {\n+        const surveyId1 = \"survey-1\";\n+        const surveyId2 = \"survey-2\";\n+\n+        const token = createTokenForLinkSurvey(surveyId1, mockUser.email);\n+        const result = verifyTokenForLinkSurvey(token, surveyId2);\n+\n+        expect(result).toBeNull();\n+      });\n+    });\n+\n+    describe(\"Expired Tokens\", () => {\n+      test(\"should reject expired tokens\", async () => {\n+        const expiredToken = jwt.sign(\n+          {\n+            id: \"encrypted_test-id\",\n+            exp: Math.floor(Date.now() / 1000) - 3600, // Expired 1 hour ago\n+          },\n+          TEST_NEXTAUTH_SECRET\n+        );\n+\n+        await expect(verifyToken(expiredToken)).rejects.toThrow(\"Invalid token\");\n+      });\n+\n+      test(\"should reject expired email change tokens\", async () => {\n+        const expiredToken = jwt.sign(\n+          {\n+            id: \"encrypted_test-id\",\n+            email: \"encrypted_test@example.com\",\n+            exp: Math.floor(Date.now() / 1000) - 3600, // Expired 1 hour ago\n+          },\n+          TEST_NEXTAUTH_SECRET\n+        );\n+\n+        await expect(verifyEmailChangeToken(expiredToken)).rejects.toThrow();\n+      });\n+    });\n+\n+    describe(\"Encryption Key Attacks\", () => {\n+      test(\"should fail gracefully with wrong encryption key\", async () => {\n+        mockSymmetricDecrypt.mockImplementation(() => {\n+          throw new Error(\"Authentication tag verification failed\");\n+        });\n+\n+        // Mock findUnique to only return user for correct decrypted ID, not ciphertext\n+        (prisma.user.findUnique as any).mockImplementation(({ where }: { where: { id: string } }) => {\n+          if (where.id === mockUser.id) {\n+            return Promise.resolve(mockUser);\n+          }\n+          return Promise.resolve(null); // Return null for ciphertext IDs\n+        });\n+\n+        const token = createToken(mockUser.id);\n+        // Should fail because ciphertext passed as userId won't match any user in DB\n+        await expect(verifyToken(token)).rejects.toThrow(/User not found/i);\n+      });\n+\n+      test(\"should handle encryption key not set gracefully\", async () => {\n+        const constants = await import(\"@/lib/constants\");\n+        const originalKey = (constants as any).ENCRYPTION_KEY;\n+        (constants as any).ENCRYPTION_KEY = undefined;\n+\n+        const token = jwt.sign(\n+          {\n+            email: \"test@example.com\",\n+            surveyId: \"test-survey-id\",\n+          },\n+          TEST_NEXTAUTH_SECRET\n+        );\n+\n+        const result = verifyTokenForLinkSurvey(token, \"test-survey-id\");\n+        expect(result).toBe(\"test@example.com\");\n+\n+        // Restore\n+        (constants as any).ENCRYPTION_KEY = originalKey;\n+      });\n+    });\n+\n+    describe(\"SQL Injection Attempts\", () => {\n+      test(\"should safely handle malicious user IDs\", async () => {\n+        const maliciousIds = [\n+          \"'; DROP TABLE users; --\",\n+          \"1' OR '1'='1\",\n+          \"admin'/*\",\n+          \"<script>alert('xss')</script>\",\n+          \"../../etc/passwd\",\n+        ];\n+\n+        for (const maliciousId of maliciousIds) {\n+          mockSymmetricDecrypt.mockReturnValueOnce(maliciousId);\n+\n+          const token = jwt.sign({ id: \"encrypted_malicious\" }, TEST_NEXTAUTH_SECRET);\n+\n+          // The function should look up the user safely\n+          await verifyToken(token);\n+          expect(prisma.user.findUnique).toHaveBeenCalledWith({\n+            where: { id: maliciousId },\n+          });\n+        }\n+      });\n+    });\n+\n+    describe(\"Token Reuse and Replay Attacks\", () => {\n+      test(\"should allow legitimate token reuse within validity period\", async () => {\n+        const token = createToken(mockUser.id);\n+\n+        // First use\n+        const result1 = await verifyToken(token);\n+        expect(result1.id).toBe(mockUser.id); // Returns decrypted user ID\n+\n+        // Second use (should still work)\n+        const result2 = await verifyToken(token);\n+        expect(result2.id).toBe(mockUser.id); // Returns decrypted user ID\n+      });\n+    });\n+\n+    describe(\"Legacy Token Compatibility\", () => {\n+      test(\"should handle legacy unencrypted tokens gracefully\", async () => {\n+        // Legacy token with plain text data\n+        const legacyToken = jwt.sign({ id: mockUser.id }, TEST_NEXTAUTH_SECRET);\n+        const result = await verifyToken(legacyToken);\n+\n+        expect(result.id).toBe(mockUser.id); // Returns raw ID from payload\n+        expect(result.email).toBe(mockUser.email);\n+      });\n+\n+      test(\"should handle mixed encrypted/unencrypted fields\", async () => {\n+        mockSymmetricDecrypt\n+          .mockImplementationOnce(() => mockUser.id) // id decrypts successfully\n+          .mockImplementationOnce(() => {\n+            throw new Error(\"Email not encrypted\");\n+          }); // email fails\n+\n+        const token = jwt.sign(\n+          {\n+            id: \"encrypted_test-id\",\n+            email: \"plain-email@example.com\",\n+          },\n+          TEST_NEXTAUTH_SECRET\n+        );\n+\n+        const result = await verifyEmailChangeToken(token);\n+        expect(result.id).toBe(mockUser.id);\n+        expect(result.email).toBe(\"plain-email@example.com\");\n+      });\n+\n+      test(\"should verify old format user tokens with email-based secrets\", async () => {\n+        // Simulate old token format with per-user secret\n+        const oldFormatToken = jwt.sign(\n+          { id: `encrypted_${mockUser.id}` },\n+          TEST_NEXTAUTH_SECRET + mockUser.email\n+        );\n+\n+        const result = await verifyToken(oldFormatToken);\n+        expect(result.id).toBe(mockUser.id); // Returns decrypted user ID\n+        expect(result.email).toBe(mockUser.email);\n+      });\n+\n+      test(\"should verify old format survey tokens with survey-based secrets\", () => {\n+        const surveyId = \"legacy-survey-id\";\n+\n+        // Simulate old survey token format\n+        const oldFormatSurveyToken = jwt.sign(\n+          { email: `encrypted_${mockUser.email}` },\n+          TEST_NEXTAUTH_SECRET + surveyId\n+        );\n+\n+        const result = verifyTokenForLinkSurvey(oldFormatSurveyToken, surveyId);\n+        expect(result).toBe(mockUser.email);\n+      });\n+\n+      test(\"should gracefully handle database errors during legacy verification\", async () => {\n+        // Create token that will fail new method\n+        const legacyToken = jwt.sign(\n+          { id: `encrypted_${mockUser.id}` },\n+          TEST_NEXTAUTH_SECRET + mockUser.email\n+        );\n+\n+        // Make database lookup fail\n+        (prisma.user.findUnique as any).mockRejectedValueOnce(new Error(\"DB connection lost\"));\n+\n+        await expect(verifyToken(legacyToken)).rejects.toThrow(\"DB connection lost\");\n+      });\n+    });\n+\n+    describe(\"Edge Cases and Error Handling\", () => {\n+      test(\"should handle database connection errors gracefully\", async () => {\n+        (prisma.user.findUnique as any).mockRejectedValue(new Error(\"Database connection failed\"));\n+\n+        const token = createToken(mockUser.id);\n+        await expect(verifyToken(token)).rejects.toThrow(\"Database connection failed\");\n+      });\n+\n+      test(\"should handle crypto module errors\", () => {\n+        mockSymmetricEncrypt.mockImplementation(() => {\n+          throw new Error(\"Crypto module error\");\n+        });\n+\n+        expect(() => createToken(mockUser.id)).toThrow(\"Crypto module error\");\n+      });\n+\n+      test(\"should validate email format in tokens\", () => {\n+        const invalidEmails = [\"\", \"not-an-email\", \"missing@\", \"@missing-local.com\", \"spaces in@email.com\"];\n+\n+        invalidEmails.forEach((invalidEmail) => {\n+          expect(() => createEmailToken(invalidEmail)).not.toThrow();\n+          // Note: JWT functions don't validate email format, they just encrypt/decrypt\n+          // Email validation should happen at a higher level\n+        });\n+      });\n+\n+      test(\"should handle extremely long inputs\", () => {\n+        const longString = \"a\".repeat(10000);\n+\n+        expect(() => createToken(longString)).not.toThrow();\n+        expect(() => createEmailToken(longString)).not.toThrow();\n+      });\n+\n+      test(\"should handle special characters in user data\", () => {\n+        const specialChars = \"!@#$%^&*()_+-=[]{}|;:'\\\",.<>?/~`\";\n+\n+        expect(() => createToken(specialChars)).not.toThrow();\n+        expect(() => createEmailToken(specialChars)).not.toThrow();\n+      });\n+    });\n+\n+    describe(\"Performance and Resource Exhaustion\", () => {\n+      test(\"should handle rapid token creation without memory leaks\", () => {\n+        const tokens: string[] = [];\n+        for (let i = 0; i < 1000; i++) {\n+          tokens.push(createToken(`user-${i}`));\n+        }\n+\n+        expect(tokens.length).toBe(1000);\n+        expect(tokens.every((token) => typeof token === \"string\")).toBe(true);\n+      });\n+\n+      test(\"should handle rapid token verification\", async () => {\n+        const token = createToken(mockUser.id);\n+\n+        const verifications: Promise<any>[] = [];\n+        for (let i = 0; i < 100; i++) {\n+          verifications.push(verifyToken(token));\n+        }\n+\n+        const results = await Promise.all(verifications);\n+        expect(results.length).toBe(100);\n+        expect(results.every((result: any) => result.id === mockUser.id)).toBe(true); // Returns decrypted user ID\n+      });\n+    });\n   });\n });"
        ]
    }
}